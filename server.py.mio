[['"""\n', '各種必要なパッケージを呼び出す / libraryをインストール\n', '"""\n', 'from enum import Enum\n', 'from datetime import datetime, timedelta\n', 'from collections import deque\n', 'import threading\n', 'import asyncio\n', 'import platform\n', 'import os\n', 'from shutil import copystat,Error,copy2,copytree,rmtree,move as shutil_move\n', 'import logging\n', 'from copy import deepcopy\n', 'import importlib\n', 'import uuid\n', 'import io\n', 'import zipfile\n', 'import base64\n', 'import subprocess\n', 'import sys\n', 'import json\n', 'from contextlib import asynccontextmanager\n', 'import pathlib'], ['', '', '', '\n', 'args = sys.argv[1:]\n', 'do_init = False\n', '#引数を処理する。\n', 'for i in args:\n', '    arg = i.split("=")\n', '    if arg[0] == "-init":\n', '        do_init = True'], ['', '', '', '', '# インストールしたいパッケージのリスト（パッケージ名: バージョン）\n', 'packages = {\n', '    "discord.py": "2.3.2",\n', '    "requests": "2.32.4",\n', '    "Flask": "3.0.3",\n', '    "ansi2html": "1.9.2",\n', '    "waitress": "3.0.1",\n', '    "aiohttp": "3.12.14",\n', '    "psutil": "5.9.0",\n', '    "uvicorn": "0.35.0",\n', '    "fastapi": "0.116.1",\n', '    "zipstream-ng": "1.8.0"\n', '}\n', 'all_packages = [f"{pkg}=={ver}" for pkg, ver in packages.items()]\n', '\n', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], ['', '', '', '\n', 'try:\n', '    from flask import Flask, render_template, jsonify, request, session, redirect, url_for, make_response, flash\n', '    from ansi2html import Ansi2HTMLConverter\n', '    import waitress\n', '\n', '    import discord \n', '    from discord import app_commands \n', '    from discord.ext import tasks\n', '    import waitress.server\n', '    import requests\n', '\n', '    import aiohttp\n', '\n', '    import psutil\n', '\n', '    from fastapi import FastAPI, HTTPException\n', '    from fastapi.responses import StreamingResponse\n', '    import uvicorn\n', '    import zipstream  # pip install zipstream-ng\n', '    from fastapi.middleware.wsgi import WSGIMiddleware\n', 'except:\n', '    print("import error. please run \'pip install -r requirements.txt\'")\n', '    sys.exit(1)'], '\n', '# 基本的な変数の読み込み\n', ['"""\n', '処理に必要な定数を宣言する\n', '"""\n', '', '', '', '', '\n', '__version__ = "2.4.5"\n', '\n', 'def get_version():\n', '    return __version__\n', '\n', '\n', 'intents = discord.Intents.default() \n', 'intents.message_content = True\n', 'client = discord.Client(intents=intents) \n', 'tree = app_commands.CommandTree(client)\n', '\n', '\n', '\n', '#プロンプトを送る\n', 'print()\n', '\n', '#サーバープロセス\n', 'process = None\n', '\n', '#起動した時刻\n', 'start_time = datetime.now().strftime("%Y-%m-%d_%H_%M_%S")\n', '\n', '#外部変数\n', 'token = None\n', 'temp_path = None \n', '\n', '#現在のディレクトリ\n', 'now_path = "/".join(__file__.replace("\\\\","/").split("/")[:-1])\n', '# 相対パス\n', 'if now_path == "": now_path = "."\n', 'now_path = os.path.abspath(now_path)\n', '#現在のファイル(server.py)\n', 'now_file = __file__.replace("\\\\","/").split("/")[-1]\n', "WEB_TOKEN_FILE = '/mikanassets/web/usr/tokens.json'\n", '\n', '#asyncioの制限を回避\n', "if platform.system() == 'Windows':\n", '    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n', '\n', '#/cmdに関する定数\n', 'cmd_logs = deque(maxlen=100)\n', '\n', '\n', 'status_lock = threading.Lock()\n', 'discord_terminal_item = deque()\n', 'discord_terminal_send_length = 0\n', 'discord_loop_is_run = False\n', '\n', '# 濃い目の黄色\n', 'bot_color = discord.Color.from_rgb(255, 242, 145)\n', 'embed_under_line_url = "https://www.dropbox.com/scl/fi/70b9ckjwrfilds65gbs11/gradient_bar.png?rlkey=922kwpi4t17lk0ju4ztbq6ofc&st=nb9saec1&dl=1"\n', 'embed_thumbnail_url = "https://www.dropbox.com/scl/fi/a21ptajqddfkhilx1e4st/mi-2025.png?rlkey=29x0wvk1np17a3nvddth0jnyk&st=s6r4f2kr&dl=1"\n', '\n', '\n', '\n', '# 権限データ\n', 'COMMAND_PERMISSION = {\n', '    "stop":1,\n', '    "start":1,\n', '    "exit":2,\n', '    "cmd serverin":1,\n', '    "cmd stdin mk":3,\n', '    "cmd stdin rm":2,\n', '    "cmd stdin mkdir":2,\n', '    "cmd stdin rmdir":2,\n', '    "cmd stdin ls":2,\n', '    "cmd stdin mv":3,\n', '    "cmd stdin send-discord":2,\n', '    "cmd stdin wget":3,\n', '    "help":0,\n', '    "backup create":1,\n', '    "backup apply":3,\n', '    # "replace":4,\n', '    "ip":0,\n', '    "logs":1,\n', '    "permission view":0,\n', '    "permission change":4,\n', '    "lang":2,\n', '    "tokengen":1,\n', '    "terminal set":1,\n', '    "terminal del":1,\n', '    "update":3,\n', '    "announce embed":4,\n', '    "status":0,\n', '}\n', '\n', 'USER_PERMISSION_MAX = max(COMMAND_PERMISSION.values())\n', '\n', 'unti_GC_obj = deque()\n', '\n', '# 拡張機能から読み込むdiscord.tasks\n', 'extension_tasks_func = []\n', '\n', '\n', 'class ModifiedEmbeds():# 名前空間として\n', '    class DefaultEmbed(discord.Embed):\n', '        def __init__(self, title, description = None, color = bot_color):\n', '            super().__init__(title=title, description=description, color=color)\n', '            self.set_image(url=embed_under_line_url)\n', '            self.set_thumbnail(url=embed_thumbnail_url)\n', '    class ErrorEmbed(discord.Embed):\n', '        def __init__(self, title, description = None, color = 0xff0000):\n', '            super().__init__(title=title, description=description, color=color)\n', '            self.set_image(url=embed_under_line_url)\n', '            self.set_thumbnail(url=embed_thumbnail_url)'], ['\n', '#ログをdiscordにも返す可能性がある\n', 'is_back_discord = False'], '\n', '# エラー時の処理\n', ['', '', '', '', 'def wait_for_keypress():\n', '    print("please press any key to continue...")\n', '    if platform.system() == "Windows":\n', '        import msvcrt\n', '        while True:\n', '            if msvcrt.kbhit():\n', '                msvcrt.getch()\n', '                break\n', '        exit()\n', '    else:\n', '        import sys\n', '        import termios\n', '        import tty\n', '        fd = sys.stdin.fileno()\n', '        old_settings = termios.tcgetattr(fd)\n', '        try:\n', '            tty.setraw(sys.stdin.fileno())\n', '            sys.stdin.read(1)\n', '        finally:\n', '            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n', '            exit()'], '\n', '# ロガー作成前なので最小限\n', ['"""\n', 'configの読み込みと最小限の変数へのロードを行う\n', '"""\n', '', '', '', '', '', '\n', '\n', 'config_file_place = now_path + "/" + ".config"\n', '\n', 'def delete_config(config_dict):\n', '    changed = False\n', '    # v2.2.0まで存在した -> 現在はupdate keyに複数要素が存在している\n', '    if "auto_update" in config_dict:\n', '        del config_dict["auto_update"]\n', '        changed = True\n', '    return changed\n', '\n', 'def make_config():\n', '    if not os.path.exists(config_file_place):\n', '        file = open(config_file_place,"w")\n', '        server_path = now_path\n', '        default_backup_path = server_path + "/../backup/" + server_path.replace("\\\\","/").split("/")[-1]\n', '        if not os.path.exists(default_backup_path):\n', '            os.makedirs(default_backup_path)\n', '        default_backup_path = os.path.realpath(default_backup_path) + "/"\n', '        print("default backup path: " + default_backup_path)\n', '        config_dict = {\\\n', '                            "allow":{"ip":True},\\\n', '                            "update":{\n', '                                "auto":True,\\\n', '                                "branch":"main",\\\n', '                            },\\\n', '                            "server_path":now_path + "/",\\\n', '                            "server_name":"bedrock_server.exe",\\\n', '                            "server_args":"",\\\n', '                            "server_char_encoding":"utf-8",\\\n', '                            "log":{"server":True,"all":False},\\\n', '                            \n', '                            "mc":True,\\\n', '                            "web":{"secret_key":"YOURSECRETKEY","port":80,"use_front_page": True},\\\n', '                            "discord_commands":{\\\n', '                                "cmd":{\\\n', '                                    "stdin":{\\\n', '                                        "sys_files": [".config",".token","logs","mikanassets"],\\\n', '                                        "send_discord":{"bits_capacity":2 * 1024 * 1024 * 1024},\\\n', '                                    },\n', '                                    "serverin":{\\\n', '                                        "allow_mccmd":["list","whitelist","tellraw","w","tell"]\\\n', '                                    }\\\n', '                                },\\\n', '                                "terminal":{"discord":False,"capacity":"inf"},\\\n', '                                "stop":{"submit":"stop"},\\\n', '                                "backup":{"path": default_backup_path,},\\\n', '                                "admin":{"members":{}},\\\n', '                                "lang":"en",\\\n', '                            },\\\n', '                            "enable_advanced_features":False,\\\n', '                        }\n', '        json.dump(config_dict,file,indent=4)\n', '        config_changed = True\n', '    else:\n', '        try:\n', '            config_dict = json.load(open(now_path + "/"  + ".config","r"))\n', '            # 不要な要素があれば削除\n', '            changed = delete_config(config_dict)\n', '        except json.decoder.JSONDecodeError:\n', '            print("config file is broken. please delete .config and try again.")\n', '            wait_for_keypress()\n', '        #要素がそろっているかのチェック\n', '        def check(cfg):\n', '            if "allow" not in cfg:\n', '                cfg["allow"] = {"ip":True}\n', '            if "ip" not in cfg["allow"]:\n', '                cfg["allow"]["ip"] = True\n', '\n', '            if "update" not in cfg:\n', '                cfg["update"] = {"auto":True,"branch":"main"}\n', '            if "auto" not in cfg["update"]:\n', '                cfg["update"]["auto"] = True\n', '            if "branch" not in cfg["update"]:\n', '                cfg["update"]["branch"] = "main"\n', '            elif "ip" not in cfg["allow"]:\n', '                cfg["allow"]["ip"] = True\n', '            if "server_path" not in cfg:\n', '                cfg["server_path"] = now_path + "/"\n', '            if "server_args" not in cfg:\n', '                cfg["server_args"] = ""\n', '            if "server_char_encoding" not in cfg:\n', '                cfg["server_char_encoding"] = "utf-8"\n', '            if "discord_commands" not in cfg:\n', '                cfg["discord_commands"] = {}\n', '            if "cmd" not in cfg["discord_commands"]:\n', '                cfg["discord_commands"]["cmd"] = {}\n', '            if "stdin" not in cfg["discord_commands"]["cmd"]:\n', '                cfg["discord_commands"]["cmd"]["stdin"] = {}\n', '            if "sys_files" not in cfg["discord_commands"]["cmd"]["stdin"]:\n', '                cfg["discord_commands"]["cmd"]["stdin"]["sys_files"] = [".config",".token","logs","mikanassets"]\n', '            if "send_discord" not in cfg["discord_commands"]["cmd"]["stdin"]:\n', '                cfg["discord_commands"]["cmd"]["stdin"]["send_discord"] = {"mode":"selfserver","bits_capacity":2 * 1024 * 1024 * 1024}\n', '            # if "mode" not in cfg["discord_commands"]["cmd"]["stdin"]["send_discord"]:\n', '            #     cfg["discord_commands"]["cmd"]["stdin"]["send_discord"]["mode"] = "selfserver"\n', '            # elif cfg["discord_commands"]["cmd"]["stdin"]["send_discord"]["mode"] not in ["selfserver","fileio"]:\n', '            #     cfg["discord_commands"]["cmd"]["stdin"]["send_discord"]["mode"] = "selfserver"\n', '            if "bits_capacity" not in cfg["discord_commands"]["cmd"]["stdin"]["send_discord"]:\n', '                cfg["discord_commands"]["cmd"]["stdin"]["send_discord"]["bits_capacity"] = 2 * 1024 * 1024 * 1024\n', '            if "serverin" not in cfg["discord_commands"]["cmd"]:\n', '                cfg["discord_commands"]["cmd"]["serverin"] = {}\n', '            if "allow_mccmd" not in cfg["discord_commands"]["cmd"]["serverin"]:\n', '                cfg["discord_commands"]["cmd"]["serverin"]["allow_mccmd"] = ["list","whitelist","tellraw","w","tell"]\n', '            if "terminal" not in cfg["discord_commands"]:\n', '                cfg["discord_commands"]["terminal"] = {"discord":False,"capacity":"inf"}\n', '            if "discord" not in cfg["discord_commands"]["terminal"]:\n', '                cfg["discord_commands"]["terminal"]["discord"] = False\n', '            if "capacity" not in cfg["discord_commands"]["terminal"]:\n', '                cfg["discord_commands"]["terminal"]["capacity"] = "inf"\n', '            if "stop" not in cfg["discord_commands"]:\n', '                cfg["discord_commands"]["stop"] = {"submit":"stop"}\n', '            elif "submit" not in cfg["discord_commands"]["stop"]:\n', '                cfg["discord_commands"]["stop"]["submit"] = "stop"\n', '            if "admin" not in cfg["discord_commands"]:\n', '                cfg["discord_commands"]["admin"] = {"members":{}}\n', '            elif "members" not in cfg["discord_commands"]["admin"]:\n', '                cfg["discord_commands"]["admin"]["members"] = {}\n', '            if "lang" not in cfg["discord_commands"]:\n', '                cfg["discord_commands"]["lang"] = "en"\n', '            if "mc" not in cfg:\n', '                cfg["mc"] = True\n', '            if "server_name" not in cfg:\n', '                cfg["server_name"] = "bedrock_server.exe"\n', '            if "log" not in cfg:\n', '                cfg["log"] = {"server":True,"all":False}\n', '            else:\n', '                if "server" not in cfg["log"]:\n', '                    cfg["log"]["server"] = True\n', '                if "all" not in cfg["log"]:\n', '                    cfg["log"]["all"] = False\n', '            if "backup" not in cfg["discord_commands"]:\n', '                try:\n', '                    server_name = cfg["server_path"].replace("\\\\","/").split("/")[-2]\n', '                except IndexError:\n', '                    print(f"server_path is broken. please check config file and try again.\\ninput : {cfg[\'server_path\']}")\n', '                    wait_for_keypress()\n', '                if server_name == "":\n', '                    print("server_path is broken. please check config file and try again.")\n', '                    wait_for_keypress()\n', '                cfg["discord_commands"]["backup"] = {}\n', '                cfg["discord_commands"]["backup"]["path"] = cfg["server_path"] + "../backup/" + server_name\n', '                cfg["discord_commands"]["backup"]["path"] = os.path.realpath(cfg["discord_commands"]["backup"]["path"]) + "/"\n', '                if not os.path.exists(cfg["discord_commands"]["backup"]["path"]):\n', '                    os.makedirs(cfg["discord_commands"]["backup"]["path"])\n', '            if "mc" not in cfg:\n', '                cfg["mc"] = True\n', '            if "web" not in cfg:\n', '                cfg["web"] = {"secret_key":"YOURSECRETKEY","port":80,"use_front_page": True}\n', '            if "port" not in cfg["web"]:\n', '                cfg["web"]["port"] = 80\n', '            if "secret_key" not in cfg["web"]:\n', '                cfg["web"]["secret_key"] = "YOURSECRETKEY"\n', '            if "use_front_page" not in cfg["web"]:\n', '                cfg["web"]["use_front_page"] = True\n', '            if "enable_advanced_features" not in cfg:\n', '                cfg["enable_advanced_features"] = False\n', '            # バージョン移行処理\n', '            # v2.0.0までは、admin.membersがlistで管理されていた(当時の権限レベルは現在の1に該当する。)\n', '            if type(cfg["discord_commands"]["admin"]["members"]) == list:\n', '                users = {}\n', '                for user in cfg["discord_commands"]["admin"]["members"]:\n', '                    users[str(user)] = 1\n', '                cfg["discord_commands"]["admin"]["members"] = users\n', '                print("admin.members is list. format changed to dict.(this version isv2.1.0 or later)")\n', '            return cfg\n', '        checked_config = check(deepcopy(config_dict))\n', '        if config_dict != checked_config or changed:\n', '            config_dict = checked_config\n', '            file = open(now_path + "/"  + ".config","w")\n', '            #ログ\n', '            config_changed = True\n', '            json.dump(config_dict,file,indent=4)\n', '            file.close()\n', '            print("config file is changed.")\n', '        else: config_changed = False\n', '    return config_dict,config_changed\n', 'def to_config_safe(config):\n', '    #"force_admin"に重複があれば削除する\n', '    save = False\n', '    if save:\n', '        file = open(config_file_place,"w")\n', '        json.dump(config,file,indent=4)\n', '        file.close()\n', '\n', 'config,config_changed = make_config()\n', '#整合性チェック\n', 'to_config_safe(config)\n', '#ロガー作成前なので最小限の読み込み\n', 'try:\n', '    log = config["log"]\n', '    server_path = config["server_path"]\n', '    if not os.path.exists(server_path):\n', '        print("not exist server_path dir")\n', '        wait_for_keypress()\n', '    #ログファイルの作成\n', '    def make_logs_file():\n', '        #./logsが存在しなければlogsを作成する\n', '        if not os.path.exists(now_path + "/" + "logs"):\n', '            os.makedirs(now_path + "/" + "logs")\n', '        if not os.path.exists(server_path + "logs"):\n', '            os.makedirs(server_path + "logs")\n', '    make_logs_file()\n', 'except KeyError:\n', '    print("(log or server_path) in config file is broken. please input true or false and try again.")\n', '    wait_for_keypress()'], '\n', '# Colorクラスの定義\n', ['', '', '', '\n', '#--------------------------------------------------------------------------------------------ログ関連\n', 'class Color(Enum):\n', "    BLACK          = '\\033[30m'#(文字)黒\n", "    RED            = '\\033[31m'#(文字)赤\n", "    GREEN          = '\\033[32m'#(文字)緑\n", "    YELLOW         = '\\033[33m'#(文字)黄\n", "    BLUE           = '\\033[34m'#(文字)青\n", "    MAGENTA        = '\\033[35m'#(文字)マゼンタ\n", "    CYAN           = '\\033[36m'#(文字)シアン\n", "    WHITE          = '\\033[37m'#(文字)白\n", "    COLOR_DEFAULT  = '\\033[39m'#文字色をデフォルトに戻す\n", "    BOLD           = '\\033[1m'#太字\n", "    UNDERLINE      = '\\033[4m'#下線\n", "    INVISIBLE      = '\\033[08m'#不可視\n", "    REVERCE        = '\\033[07m'#文字色と背景色を反転\n", "    BG_BLACK       = '\\033[40m'#(背景)黒\n", "    BG_RED         = '\\033[41m'#(背景)赤\n", "    BG_GREEN       = '\\033[42m'#(背景)緑\n", "    BG_YELLOW      = '\\033[43m'#(背景)黄\n", "    BG_BLUE        = '\\033[44m'#(背景)青\n", "    BG_MAGENTA     = '\\033[45m'#(背景)マゼンタ\n", "    BG_CYAN        = '\\033[46m'#(背景)シアン\n", "    BG_WHITE       = '\\033[47m'#(背景)白\n", "    BG_DEFAULT     = '\\033[49m'#背景色をデフォルトに戻す\n", "    RESET          = '\\033[0m'#全てリセット\n", '    def __add__(self, other):\n', '        if isinstance(other, Color):\n', '            return self.value + other.value\n', '        elif isinstance(other, str):\n', '            return self.value + other\n', '        else:\n', '            raise NotImplementedError\n', '    def __radd__(self, other):\n', '        if isinstance(other, Color):\n', '            return other.value + self.value\n', '        elif isinstance(other, str):\n', '            return other + self.value\n', '        else:\n', '            raise NotImplementedError'], '\n', '# ログのフォーマットクラス作成\n', ['"""\n', 'loggerで用いるフォーマッタの定義\n', '"""\n', '', '', '', '', '', '\n', 'class Formatter():\n', '    levelname_size = 8\n', '    name_size = 10\n', '    class ColoredFormatter(logging.Formatter):\n', '        # ANSI escape codes for colors\n', '        COLORS = {\n', "            'DEBUG': Color.BOLD + Color.WHITE,   # White\n", "            'INFO': Color.BOLD + Color.BLUE,    # Blue\n", "            'WARNING': Color.BOLD + Color.YELLOW, # Yellow\n", "            'ERROR': Color.BOLD + Color.RED,   # Red\n", "            'CRITICAL': Color.BOLD + Color.MAGENTA # Red background\n", '        }\n', "        RESET = '\\033[0m'  # Reset color\n", '        BOLD_BLACK = Color.BOLD + Color.BLACK  # Bold Black\n', '\n', '        def format(self, record):\n', '            # Format the asctime\n', '            record.asctime = self.formatTime(record, self.datefmt)\n', '            bold_black_asctime = f"{self.BOLD_BLACK}{record.asctime}{self.RESET}"\n', '            \n', '            # Adjust level name to be 8 characters long\n', '            original_levelname = record.levelname\n', '            padded_levelname = original_levelname.ljust(Formatter.levelname_size)\n', '            original_name = record.name\n', '            padded_name = original_name.ljust(Formatter.name_size)\n', '            \n', '            # Apply color to the level name only\n', '            color = self.COLORS.get(original_levelname, self.RESET)\n', '            colored_levelname = f"{color}{padded_levelname}{self.RESET}"\n', '            \n', '            # Get the formatted message\n', '            message = record.getMessage()\n', '            \n', '            # Create the final formatted message\n', '            formatted_message = f"{bold_black_asctime} {colored_levelname} {padded_name}: {message}"\n', '            \n', '            return formatted_message\n', '\n', '    class MinecraftFormatter(logging.Formatter):\n', '        \n', '        # ANSI escape codes for colors\n', '        COLORS = {\n', "            'SERVER': Color.BOLD + Color.GREEN,   # Green\n", '        }\n', "        RESET = '\\033[0m'  # Reset color\n", '        BOLD_BLACK = Color.BOLD + Color.BLACK  # Bold Black\n', '\n', '        def format(self, record):\n', '            # Format the asctime\n', '            record.asctime = self.formatTime(record, self.datefmt)\n', '            bold_black_asctime = f"{self.BOLD_BLACK}{record.asctime}{self.RESET}"\n', '            \n', '            # Apply color to the level name only\n', '            color = self.COLORS["SERVER"]\n', '            colored_levelname = f"{color}SERVER  {self.RESET}"\n', '            \n', '            # Get the formatted message\n', '            message = record.getMessage()\n', '            # msg_type = message.split()\n', '            # if len(msg_type) > 2:\n', '            #     msg_type = msg_type[2][:-1]\n', '            # if msg_type == "INFO":\n', '            #     msg_color = Color.CYAN\n', '            # elif msg_type == "ERROR":\n', '            #     msg_color = Color.RED\n', '            # else:\n', '            #     msg_color = Color.RESET\n', '            what_type = message.upper()\n', '            if "INFO" in what_type:\n', '                msg_color = Color.CYAN\n', '            elif "ERROR" in what_type:\n', '                msg_color = Color.RED\n', '            elif "WARN" in what_type:\n', '                msg_color = Color.YELLOW\n', '            else:\n', '                msg_color = Color.RESET\n', '\n', '            message = msg_color + message + Color.RESET\n', '            \n', '            # Create the final formatted message\n', '            formatted_message = f"{bold_black_asctime} {colored_levelname} {message}"\n', '            \n', '            return formatted_message\n', '    class WebFormatter(logging.Formatter):\n', '        def __init__(self, prefix, *args, **kwargs):\n', '            super().__init__(*args, **kwargs)\n', '            self.COLORS = {\n', "                'FLASK': Color.BOLD + Color.CYAN,   # Green\n", '            }\n', "            self.RESET = '\\033[0m'  # Reset color\n", '            self.BOLD_BLACK = Color.BOLD + Color.BLACK  # Bold Black\n', '            self.prefix = prefix\n', '        def format(self, record):\n', '            # Format the asctime\n', '            record.asctime = self.formatTime(record, self.datefmt)\n', '            bold_black_asctime = f"{self.BOLD_BLACK}{record.asctime}{self.RESET}"\n', '            \n', '            # Apply color to the level name only\n', '            color = self.COLORS["FLASK"]\n', '            colored_levelname = f"{color}{self.prefix.ljust(Formatter.levelname_size)}{self.RESET}"\n', '            \n', '            # Get the formatted message\n', '            message = record.getMessage()\n', '\n', '            message = message + Color.RESET\n', '            \n', '            # Create the final formatted message\n', '            formatted_message = f"{bold_black_asctime} {colored_levelname} {message}"\n', '            \n', '            return formatted_message\n', '\n', '    class DefaultConsoleFormatter(logging.Formatter):\n', '        def format(self, record):\n', '            # Format the asctime\n', '            record.asctime = self.formatTime(record, self.datefmt)\n', '            \n', '            # Adjust level name to be 8 characters long\n', '            original_levelname = record.levelname\n', '            padded_levelname = original_levelname.ljust(Formatter.levelname_size)\n', '            original_name = record.name\n', '            padded_name = original_name.ljust(Formatter.name_size)\n', '            \n', '            \n', '            # Get the formatted message\n', '            message = record.getMessage()\n', '            \n', '            # Create the final formatted message\n', '            formatted_message = f"{record.asctime} {padded_levelname} {padded_name}: {message}"\n', '            \n', '            return formatted_message\n', '        \n', '    class MinecraftConsoleFormatter(logging.Formatter):\n', '        def format(self, record):\n', '            # Format the asctime\n', '            record.asctime = self.formatTime(record, self.datefmt)\n', '            \n', '            padded_levelname = "SERVER".ljust(Formatter.levelname_size)\n', '            \n', '            \n', '            # Get the formatted message\n', '            message = record.getMessage()\n', '            \n', '            # Create the final formatted message\n', '            formatted_message = f"{record.asctime} {padded_levelname} {message}"\n', '            \n', '            return formatted_message\n', '    class WebConsoleFormatter(logging.Formatter):\n', '        def __init__(self, prefix, fmt = None, datefmt = None, style = "%", validate = True, *, defaults = None):\n', '            super().__init__(fmt, datefmt, style, validate, defaults=defaults)\n', '            self.prefix = prefix\n', '        def format(self, record):\n', '            # Format the asctime\n', '            record.asctime = self.formatTime(record, self.datefmt)\n', '            \n', '            padded_levelname = self.prefix.ljust(Formatter.levelname_size)\n', '            \n', '            \n', '            # Get the formatted message\n', '            message = record.getMessage()\n', '            \n', '            # Create the final formatted message\n', '            formatted_message = f"{record.asctime} {padded_levelname} {message}"\n', '            \n', '            return formatted_message\n', '        \n', '    # カスタムフィルタ（/get_console_data を除外）\n', '    class ExcludeConsoleDataFilter(logging.Filter):\n', '        def filter(self, record: logging.LogRecord) -> bool:\n', '            return "/get_console_data" not in record.getMessage()\n', '\n', '\n', '#logger\n', "dt_fmt = '%Y-%m-%d %H:%M:%S'\n", "console_formatter = Formatter.ColoredFormatter(f'{Color.BOLD + Color.BG_BLACK}%(asctime)s %(levelname)s %(name)s: %(message)s', dt_fmt)\n", "file_formatter = Formatter.DefaultConsoleFormatter('%(asctime)s %(levelname)s %(name)s: %(message)s', dt_fmt)\n"], '\n', '# ロガーの作成および設定\n', ['"""\n', 'ロガーの作成および設定を行う\n', '"""\n', '', '', '', '', '', '', '\n', '#/log用のログ保管場所\n', 'log_msg = deque(maxlen=100)\n', '#discord送信用のログ\n', 'discord_log_msg = deque() \n', 'def create_logger(name,console_formatter=console_formatter,file_formatter=file_formatter):\n', '    class DequeHandler(logging.Handler):\n', '        def __init__(self, deque):\n', '            super().__init__()\n', '            self.deque = deque\n', '\n', '        def emit(self, record):\n', '            log_entry = self.format(record)\n', '            self.deque.append(log_entry)\n', '    class DiscordHandler(logging.Handler):\n', '        def __init__(self,deque):\n', '            super().__init__()\n', '            self.deque = deque\n', '        def emit(self, record):\n', '            log_entry = self.format(record)\n', '            self.deque.append(log_entry)\n', '    logger = logging.getLogger(name)\n', '    logger.setLevel(logging.INFO)\n', '    console = logging.StreamHandler(sys.stdout)\n', '    console.setLevel(logging.INFO)\n', '    console.setFormatter(console_formatter)\n', '    logger.addHandler(console)\n', '    if log["all"]:\n', '        f = start_time + ".log"\n', '        file = logging.FileHandler(now_path + "/logs/all " + f,encoding="utf-8")\n', '        file.setLevel(logging.DEBUG)\n', '        file.setFormatter(file_formatter)\n', '        logger.addHandler(file)\n', '    deque_handler = DequeHandler(log_msg)\n', '    deque_handler.setLevel(logging.DEBUG)\n', '    deque_handler.setFormatter(console_formatter)  # フォーマットは任意で設定\n', '    discord_handler = DiscordHandler(discord_log_msg)\n', '    discord_handler.setLevel(logging.DEBUG)\n', '    discord_handler.setFormatter(console_formatter)  # フォーマットは任意で設定\n', '    logger.addHandler(deque_handler)\n', '    logger.addHandler(discord_handler)\n', '    return logger\n', '\n', 'def get_log():\n', '    return log_msg\n', '\n', '#ロガーの作成\n', 'logger_name = ["stop", "start", "exit", "ready", "cmd", "help", "backup", "replace", "ip", "sys"]\n', '\n', 'stop_logger = create_logger("stop")\n', 'start_logger = create_logger("start")\n', 'exit_logger = create_logger("exit")\n', 'ready_logger = create_logger("ready")\n', 'cmd_logger = create_logger("cmd")\n', 'help_logger = create_logger("help")\n', 'backup_logger = create_logger("backup")\n', 'replace_logger = create_logger("replace")\n', 'ip_logger = create_logger("ip")\n', 'sys_logger = create_logger("sys")\n', 'log_logger = create_logger("log")\n', 'permission_logger = create_logger("permission")\n', 'admin_logger = create_logger("admin")\n', 'lang_logger = create_logger("lang")\n', 'token_logger = create_logger("token")\n', 'terminal_logger = create_logger("terminal")\n', 'base_extension_logger = create_logger("extension")\n', 'update_logger = create_logger("update")\n', 'announce_logger = create_logger("send")\n', 'status_logger = create_logger("status")\n', 'minecraft_logger = create_logger("minecraft",Formatter.MinecraftFormatter(f\'{Color.BOLD + Color.BG_BLACK}%(asctime)s %(levelname)s %(name)s: %(message)s\', dt_fmt),Formatter.MinecraftConsoleFormatter(\'%(asctime)s %(levelname)s %(name)s: %(message)s\', dt_fmt))\n'], '\n', '# 残りのconfig読み出し\n', ['', '', '', '', '', '', '\n', '#configの読み込み\n', 'try:\n', '    allow_cmd = set(config["discord_commands"]["cmd"]["serverin"]["allow_mccmd"])\n', '    server_name = config["server_name"]\n', '    server_args = config["server_args"].split(" ")\n', '    if not os.path.exists(server_path + server_name):\n', '        sys_logger.error("not exist " + server_path + server_name + " file. please check your config.")\n', '        wait_for_keypress()\n', '    allow = {"ip":config["allow"]["ip"]}\n', '    log = config["log"]\n', '    now_dir = server_path.replace("\\\\","/").split("/")[-2]\n', '    backup_path = config["discord_commands"]["backup"]["path"]\n', '    lang = config["discord_commands"]["lang"]\n', '    bot_admin = config["discord_commands"]["admin"]["members"]\n', '    flask_secret_key = config["web"]["secret_key"]\n', '    web_port = config["web"]["port"]\n', '    STOP = config["discord_commands"]["stop"]["submit"]\n', '    where_terminal = config["discord_commands"]["terminal"]["discord"]\n', '    is_auto_update = config["update"]["auto"]\n', '    update_branch = config["update"]["branch"]\n', '    enable_advanced_features = config["enable_advanced_features"]\n', '    sys_files = config["discord_commands"]["cmd"]["stdin"]["sys_files"]\n', '    if config["discord_commands"]["terminal"]["capacity"] == "inf":\n', '        terminal_capacity = float("inf")\n', '    else:\n', '        terminal_capacity = config["discord_commands"]["terminal"]["capacity"]\n', '    # send_discord_mode = config["discord_commands"]["cmd"]["stdin"]["send_discord"]["mode"]\n', '    send_discord_bits_capacity = config["discord_commands"]["cmd"]["stdin"]["send_discord"]["bits_capacity"]\n', '    use_flask_server = config["web"]["use_front_page"]\n', '    server_char_code = config["server_char_encoding"]\n', '    \n', 'except KeyError:\n', '    sys_logger.error("config file is broken. please delete .config and try again.")\n', '    wait_for_keypress()\n', '\n', 'sys_logger.info("advanced features -> " + str(enable_advanced_features))'], '\n', '# ファイルの作成/修正/アップデート\n', ['', '', '', '', '', '', '', '', '\n', '\n', 'repository = {\n', '    "user": "sleeping-mikan",\n', '    "name": "server-bot-v2",\n', '    "branch": update_branch,#!debug else main\n', '} \n', '\n', 'def get_self_commit_id():\n', '    url = f\'https://api.github.com/repos/{repository["user"]}/{repository["name"]}/contents/server.py?ref={repository["branch"]}\'\n', '    response = requests.get(url)\n', '    if response.status_code != 200:\n', '        sys_logger.error("github api error. status code: " + str(response.status_code))\n', '        return None\n', '    commit_id = response.json()["sha"]\n', '    return commit_id\n', '\n', '\n', '\n', '\n', 'is_first_run = False\n', '\n', '# mikanassets/extensionフォルダを作成\n', 'if not os.path.exists(now_path + "/mikanassets/extension"):\n', '    # 最初の起動の場合にはフラグを立てておく\n', '    is_first_run = True\n', '    os.makedirs(now_path + "/mikanassets/extension")\n', '\n', '#updateプログラムが存在しなければdropboxから./update.pyにコピーする\n', 'if not os.path.exists(now_path + "/mikanassets"):\n', '    os.makedirs(now_path + "/mikanassets")\n', 'if not os.path.exists(now_path + "/mikanassets/" + "update.py") or do_init:\n', "    url='https://www.dropbox.com/scl/fi/zo824cfk88uj52sospwo6/update_v2.2.py?rlkey=vwkh78smhdbm2pnfyegyxjpgf&st=6wdv9o5w&dl=1'\n", "    filename= now_path + '/mikanassets/' + 'update.py'\n", '\n', '    urlData = requests.get(url).content\n', '\n', "    with open(filename ,mode='wb') as f: # wb でバイト型を書き込める\n", '        f.write(urlData)\n', 'def save_mikanassets_dat():\n', '    if not os.path.exists(now_path + "/mikanassets"):\n', '        os.makedirs(now_path + "/mikanassets")\n', '    if not os.path.exists(os.path.join(now_path, "mikanassets", ".dat")):\n', '        # 存在しなければデータファイルを作成する(現状 commit id 保管用)\n', '        file = open(os.path.join(now_path, "mikanassets", ".dat"), "w")\n', '        file.write(\'{"commit_id":\' + f\'"{get_self_commit_id()}"\' + \'}\')\n', '        file.close()\n', '', '', '', '', '', '', '', '', '', '', '', '', '', 'save_mikanassets_dat()\n', '    #os.system("curl https://www.dropbox.com/scl/fi/w93o5sndwaiuie0otorm4/update.py?rlkey=gh3gqbt39iwg4afey11p99okp&st=2i9a9dzp&dl=1 -o ./update.py")\n', 'if not os.path.exists(now_path + "/mikanassets/web"):\n', '    os.makedirs(now_path + "/mikanassets/web")\n', 'if not os.path.exists(now_path + "/mikanassets/web/index.html") or do_init:\n', "    url='https://www.dropbox.com/scl/fi/04to7yrstmgdz9j09ljy2/index.html?rlkey=7q8eu0nooj8zy34dguwwsbkjd&st=4cb6y9sr&dl=1'\n", "    filename= now_path + '/mikanassets/web/index.html'\n", '    urlData = requests.get(url).content\n', "    with open(filename ,mode='wb') as f: # wb でバイト型を書き込める\n", '        f.write(urlData)\n', 'if not os.path.exists(now_path + "/mikanassets/web/login.html") or do_init:\n', "    url='https://www.dropbox.com/scl/fi/6yuq2dhqozxeh8vxj8wgy/login.html?rlkey=9w9tbevra7r9vwjeofslb8j0x&st=sxtayji2&dl=1'\n", "    filename= now_path + '/mikanassets/web/login.html'\n", '    urlData = requests.get(url).content\n', "    with open(filename ,mode='wb') as f: # wb でバイト型を書き込める\n", '        f.write(urlData)\n', '#mikanassets/web/usr/tokens.jsonを作成\n', 'if not os.path.exists(now_path + "/mikanassets/web/usr"):\n', '    os.makedirs(now_path + "/mikanassets/web/usr")\n', 'if not os.path.exists(now_path + "/mikanassets/web/usr/tokens.json"):\n', '    #ファイルを作成\n', '    tokenfile_items = {"tokens":[]}\n', '    file = open(now_path + "/mikanassets/web/usr/tokens.json","w",encoding="utf-8")\n', '    file.write(json.dumps(tokenfile_items,indent=4))\n', '    file.close()\n', '    del tokenfile_items\n', 'if not os.path.exists(now_path + "/mikanassets/web/pictures"):\n', '    os.makedirs(now_path + "/mikanassets/web/pictures")\n', 'if not os.path.exists(now_path + "/mikanassets/web/pictures/icon.png") or do_init:\n', "    url = 'https://www.dropbox.com/scl/fi/cr6uejk7s2vk4zevm8zc6/boticon.png?rlkey=szuisf29w1rnynz9xs9ucr24l&st=a8kuy1fd&dl=1'\n", "    filename= now_path + '/mikanassets/web/pictures/icon.png'\n", '    urlData = requests.get(url).content\n', "    with open(filename ,mode='wb') as f: # wb でバイト型を書き込める\n", '        f.write(urlData)\n', '\n', 'def read_web_tokens():\n', '    file = open(now_path + "/mikanassets/web/usr/tokens.json","r",encoding="utf-8")\n', '    tokens = json.load(file)["tokens"]\n', '    file.close()\n', '    return tokens\n', '\n', 'web_tokens = read_web_tokens()\n', '\n', 'def make_token_file():\n', '    global token\n', '    #./.tokenが存在しなければ.tokenを作成する\n', '    if not os.path.exists(now_path + "/" + ".token"):\n', '        file = open(now_path + "/" + ".token","w",encoding="utf-8")\n', '        file.write("ここにtokenを入力")\n', '        file.close()\n', '        sys_logger.error("please write token in" + now_path + "/" +".token")\n', '        #ブロッキングする\n', '        wait_for_keypress()\n', '    #存在するならtokenを読み込む(json形式)\n', '    else:\n', '        token = open(now_path + "/" + ".token","r",encoding="utf-8").read()\n', '\n', 'def make_temp():\n', '    global temp_path\n', '    #tempファイルの作成場所\n', "    if platform.system() == 'Windows':\n", '        # %temp%/mcserver を作成\n', '        temp_path = os.environ.get(\'TEMP\') + "/mcserver"\n', '    else:\n', '        # /tmp/mcserver を作成\n', '        temp_path = "/tmp/mcserver"\n', '\n', '    #tempファイルの作成\n', '    if not os.path.exists(temp_path):\n', '        os.mkdir(temp_path)\n', '\n', 'async def update_self_if_commit_changed(interaction: discord.Interaction | None = None,embed: ModifiedEmbeds.DefaultEmbed | None = None, text_pack: dict | None = None, sender = None, is_force = False):\n', '    # ファイルが存在しなければ作る\n', '    if not os.path.exists(os.path.join(now_path, "mikanassets", ".dat")):\n', '        save_mikanassets_dat()\n', '    file = open(os.path.join(now_path, "mikanassets", ".dat"))\n', '    # 現在のserver.pyのコミットidを取り出す\n', '    try:\n', '        data = json.load(file)\n', '        commit = data["commit_id"]\n', '    except:\n', '        if interaction is not None and embed is not None:\n', '            embed.add_field(name="error", value="json load error (mikanassets/.dat). delete file.", inline=False)\n', '            await sender(interaction=interaction,embed=embed)\n', '        update_logger.error("json load error (mikanassets/.dat). delete file.")\n', '    file.close()\n', '    # github/mainのコミットidを取り出す\n', '    github_commit = get_self_commit_id()\n', '    update_logger.info("github commit -> " + github_commit)\n', '    update_logger.info(" local commit -> " + commit)\n', '    # 戻り値が正常でない場合\n', '    if github_commit == None:\n', '        if interaction is not None and embed is not None:\n', '            embed.add_field(name="error", value="github response error.", inline=False)\n', '            await sender(interaction=interaction,embed=embed)\n', '        update_logger.error("github commit is None.")\n', '    # コミットid出力\n', '    if interaction is not None and embed is not None:\n', '        embed.add_field(name="github commit", value=github_commit, inline=False)\n', '        embed.add_field(name="local commit", value=commit, inline=False)\n', '        await sender(interaction=interaction,embed=embed)\n', '    # 更新がない場合\n', '    if commit == github_commit and not is_force: \n', '        if interaction is not None and embed is not None:\n', '            embed.add_field(name="", value=text_pack["same"], inline=False)\n', '            await sender(interaction=interaction,embed=embed)\n', '        update_logger.info("commit is same. no update.")\n', '        return\n', '    # ファイルに新しいcommit id を書き込む\n', '    data["commit_id"] = github_commit\n', '    file = open(os.path.join(now_path, "mikanassets", ".dat"), "w")\n', '    json.dump(data, file)\n', '    file.close()\n', '    # ローカルとgithubのコードが違ったことを出力\n', '    if interaction is not None and embed is not None:\n', '        if is_force:\n', '            embed.add_field(name="", value=text_pack["force"], inline=False)\n', '        else:\n', '            embed.add_field(name="", value=text_pack["different"], inline=False)\n', '        await sender(interaction=interaction,embed=embed)\n', '    update_logger.info("commit changed. update self.")\n', '    # コードを要求\n', '    url=f\'https://api.github.com/repos/{repository["user"]}/{repository["name"]}/contents/server.py?ref={repository["branch"]}\'\n', '    # temp_path + "/new_source.py にダウンロード\n', '    response = requests.get(url)\n', '    if response.status_code != 200:\n', '        sys_logger.error("response error. status_code : " + str(response.status_code))\n', '        if interaction is not None and embed is not None:\n', '            embed.add_field(name="error : raw.githubusercontent.com response error", value="", inline=False)\n', '            await sender(interaction=interaction,embed=embed)\n', '        return\n', '    # temp_path + "/new_source.py に書き換え予定ファイル(新しいserver.py)を作成\n', '    with open(temp_path + "/new_source.py", "w", encoding="utf-8") as f:\n', '        f.write(base64.b64decode(response.json()["content"]).decode(\'utf-8\').replace("\\r\\n","\\n"))\n', '    # discordにコードを置き換える\n', '    msg_id = str(0)\n', '    channel_id = str(0)\n', '    if interaction is not None and embed is not None:\n', '        msg_id = str((await interaction.original_response()).id)\n', '        channel_id = str(interaction.channel_id)\n', '        embed.add_field(name="", value=text_pack["replace"].format(channel_id,msg_id), inline=False)\n', '        await sender(interaction=interaction,embed=embed)\n', '    replace_logger.info("call update.py")\n', '    replace_logger.info(\'replace args : \' + msg_id + " " + channel_id)\n', '    os.execv(sys.executable,["python3",now_path + "/mikanassets/" + "update.py",temp_path + "/new_source.py",msg_id,channel_id,now_file])\n', '\n', '\n', '\n', 'make_token_file()\n', 'make_temp()\n', 'if is_auto_update:\n', '    asyncio.run(update_self_if_commit_changed())'], '\n', '# mcサーバー用properties読み込み\n', ['', '', '', '', '', '', '\n', '\n', '#java properties の読み込み\n', 'def properties_to_dict(filename):\n', '    properties = {}\n', '    try:\n', '        with open(filename) as file:\n', '            for line in file:\n', '                line = line.strip()\n', "                if line and not line.startswith('#'):\n", "                    if line.startswith(' ') or line.startswith('\\t'):\n", '                        line = line[1:]\n', "                    key, value = line.split('=', 1)\n", '                    properties[key] = value\n', '        return properties\n', '    except Exception as e:#ファイルが存在しなければ存在しないことを出力して終了\n', '        sys_logger.error(e)\n', '        sys_logger.info("not exist server.properties file in " + server_path + ". if you are not using a minecraft server, please set mc to false in .config .if not, restart it and server.properties should be generated in the server hierarchy.")\n', '        return {}\n', '\n', '#minecraftサーバーであればpropertiesを読み込む\n', 'if config["mc"]:\n', '    properties = properties_to_dict(server_path + "server.properties")\n', '    sys_logger.info("read properties file -> " + server_path + "server.properties")\n', '\n', '#コマンド利用ログ\n', 'use_stop = False'], '\n', '# テキスト関連データの作成\n', ['', '', '', '', '', '', '', '', '', '\n', '\n', 'async def get_text_dat():\n', '    global HELP_MSG, COMMAND_DESCRIPTION, send_help, RESPONSE_MSG, ACTIVITY_NAME \n', '# テキストデータ領域-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n', '\n', '#help\n', '    HELP_MSG = {\n', '        "ja":{\n', '            "/stop             ":"サーバーを停止します。但し起動していない場合にはエラーメッセージを返します。",\n', '            "/start            ":"サーバーを起動します。但し起動している場合にはエラーメッセージを返します。",\n', '            "/exit             ":"botを終了します。サーバーを停止してから実行してください。終了していない場合にはエラーメッセージを返します。\\nまたこのコマンドを実行した場合次にbotが起動するまですべてのコマンドが無効になります。",\n', '            "/cmd serverin     ":f"/cmd <mcコマンド> を用いてサーバーコンソール上でコマンドを実行できます。使用できるコマンドは{allow_cmd}です。",\n', '            "/cmd stdin        ":"/cmd stdin <ls|rm|mk|mv|rmdir|mkdir|wget|send-discord>を用いて、ファイル確認/削除/作成/移動/フォルダ作成/フォルダ削除/urlからダウンロード/discord送信を実行できます。例えばサーバーディレクトリ直下にa.txtを作成する場合は/cmd stdin mk a.txtと入力します。",\n', '            "/backup create    ":"/backup create [directory] でデータをバックアップします。ディレクトリ名を省略した場合worldsをコピーします。",\n', '            "/backup apply     ":"/backup apply <directory> でデータをバックアップから復元します。",\n', '            # "/replace          ":"/replace <py file> によってbotのコードを置き換えます。",\n', '            "/ip               ":"サーバーのIPアドレスを表示します。",\n', '            "/logs             ":"サーバーのログを表示します。引数を与えた場合にはそのファイルを、与えられなければ動作中に得られたログから最新の10件を返します。",\n', '            "/permission change":"/permission change <level> <user> で、userのbot操作権利を変更できます。必要な権限レベルは/permission viewで確認できます。",\n', '            "/permission view  ":"/permission view <user> で、userのbot操作権利を表示します。",\n', '            "/lang             ":"/lang <lang> で、botの言語を変更します。",\n', '            "/tokengen         ":"/tokengen で、webでログインするためのトークンを生成します。",\n', '            "/terminal set     ":"/terminal set <ch> で、サーバーのコンソールを実行したチャンネルに紐づけます。chが省略された場合は現在のチャンネルに紐づけます。",\n', '            "/terminal del     ":"/terminal del で、サーバーのコンソールを実行したチャンネルを解除します。",\n', '            "/announce         ":"/announce embed <file | text> で、サーバーにmimd形式のメッセージを送信します。タイトルを|title|に続けて設定し、以後\\\\nで改行を行い内容を記述してください。",\n', '            "/status           ":"/status で、サーバーの状態を表示します。",\n', '        },\n', '        "en":{\n', '            "/stop             ":"Stop the server. If the server is not running, an error message will be returned.",\n', '            "/start            ":"Start the server. If the server is running, an error message will be returned.",\n', '            "/exit             ":"Exit the bot. Stop the server first and then run the command. If the server is not running, an error message will be returned.\\n",\n', '            "/cmd serverin     ":f"/cmd <mc command> can be used to execute commands in the server console. The available commands are {allow_cmd}.",\n', '            "/cmd stdin        ":"/cmd stdin <ls|rm|mk|mv|rmdir|mkdir|wget|send-discord> can be used to execute commands in the server console. For example, to create a file in the server directory, you can type /cmd stdin mk a.txt.",\n', '            "/backup create    ":"/backup create [directory] creates data. If the directory name is omitted, worlds is copied.",\n', '            "/backup apply     ":"/backup apply <directory> recovers data from a backup.",\n', '            # "/replace          ":"/replace <py file> replaces the bot\'s code.",\n', '            "/ip               ":"The server\'s IP address will be displayed to discord.",\n', '            "/logs             ":"Display the server\'s logs. If an argument is given, that file will be returned. If no argument is given, the latest 10 logs will be returned.",\n', '            "/permission change":"/permission change <level> <user> changes the user\'s bot operation rights. The required permission level can be checked by /permission view.",\n', '            "/permission view  ":"/permission view <user> displays the user\'s bot operation rights.",\n', '            "/lang             ":"/lang <lang> changes the bot\'s language.",\n', '            "/tokengen         ":"/tokengen generates a token for login to the web.",\n', '            "/terminal set     ":"/terminal set <ch> connects the server\'s console to a channel. If ch is omitted, the current channel is connected.",\n', '            "/terminal del     ":"/terminal del disconnects the server\'s console from a channel.",\n', '            "/announce         ":"/announce embed <file | text> sends an embed message to the server. Set the title after |title| and enter the content after \\\\n.",\n', '            "/status           ":"/status displays the status of the server.",\n', '        },\n', '    }\n', '        \n', '\n', '    COMMAND_DESCRIPTION = {\n', '        "ja":{\n', '            "stop":"サーバーを停止します。",\n', '            "start":"サーバーを起動します。",\n', '            "exit":"botを終了します。",\n', '            "cmd":{\n', '                "serverin":"サーバーにマインクラフトコマンドを送信します。",\n', '                "stdin": {\n', '                    "main": "サーバーディレクトリ以下に対するコマンドをサーバーの外側から実行します。",\n', '                    "mk": "指定した相対パスを渡されたファイルまたは空にします。",\n', '                    "rm": "指定した相対パスに完全一致するファイルを削除します。",\n', '                    "ls": "指定したサーバーからの相対パスに存在するファイルを表示します。",\n', '                    "mkdir": "指定した相対パスに新しいディレクトリを作成します。",\n', '                    "rmdir": "指定した相対パスのディレクトリを再帰的に削除します。",\n', '                    "mv": "指定したパスにあるファイルを別のパスに移動します。",\n', '                    "send-discord": "discordにファイルを送信します。",\n', '                    "wget": "urlからファイルをダウンロードします。",\n', '                },\n', '            },\n', '            "backup":{\n', '                "create":"サーバーデータをバックアップします。引数にはバックアップを取りたい対象のパスを指定します。入力しない場合worldsが選択されます。",\n', '\n', '            },\n', '            # "replace":"<非推奨> このbotのコードを<py file>に置き換えます。このコマンドはbotを破壊する可能性があります。",\n', '            "ip":"サーバーのIPアドレスを表示します。",\n', '            "logs":"サーバーのログを表示します。引数にはファイル名を指定します。入力しない場合は最新の10件のログを返します。",\n', '            "help":"このbotのコマンド一覧を表示します。",\n', '            "permission":{\n', '                "change":"選択したユーザに対してbotをdiscord管理者と同等の権限で操作できるようにします。",\n', '                "view":"選択したユーザに対してbot操作権限を表示します。",\n', '            },\n', '            "lang":"botの言語を変更します。引数には言語コードを指定します。",\n', '            "tokengen":"webにログインするためのトークンを生成します。",\n', '            "terminal":{\n', '                "set":"サーバーのコンソールを実行したチャンネルに紐づけます。",\n', '                "del":"コンソール紐づけを実行したチャンネルから解除します。",\n', '            },\n', '            "update":"botを更新します。非推奨となった/replaceの後継コマンドです。",\n', '            "announce":{\n', '                "embed":"discordにテキストをembedで送信します。引数にはmd形式のテキストファイルを指定するか、文字列を指定します。",\n', '            },\n', '            "status": "プロセスの状態を表示します。",\n', '        },\n', '        "en":{\n', '            "stop":"Stop the server.",\n', '            "start":"Start the server.",\n', '            "exit":"Exit the bot.",\n', '            "cmd":{\n', '                "serverin":"Send a Minecraft command to the server.",\n', '                "stdin":{\n', '                    "main":"Execute the command in the server\'s directory outside the server.",\n', '                    "mk":"Set the file specified by the relative path from the server.",\n', '                    "rm":"Delete the file specified by the relative path from the server.",\n', '                    "ls":"Display the file specified by the relative path from the server.",\n', '                    "mkdir":"Create a new directory specified by the relative path from the server.",\n', '                    "rmdir":"Recursively delete the directory specified by the relative path from the server.",\n', '                    "mv":"Move the file specified by the path to another path.",\n', '                    "send-discord":"Send a file to discord.",\n', '                    "wget":"Download a file from a url.",\n', '                },\n', '            },\n', '            "backup":{\n', '                "create":"Create a backup of the server\'s data. Specify the path of the backup to be created.",\n', '\n', '            },\n', '            # "replace":"<Not recommended> Replace the bot\'s code with <py file>.",\n', '            "ip":"The server\'s IP address will be displayed to discord.",\n', '            "logs":"Display server logs. With an argument, return that file. Without, return the latest 10 logs.",\n', '            "help":"Display this bot\'s command list.",\n', '            "permission":{\n', '                "view": "Display the bot operation rights of the selected user.",\n', '                "change":"Force the selected user to have the same permissions as the bot, as discord administrator.",\n', '            },\n', '            "lang":"Change the bot\'s language. With an argument, specify the language code.",\n', '            "tokengen":"Generate a token for login to the web.",\n', '            "terminal":{\n', '                "set":"Connect the server\'s console to a channel.",\n', '                "del":"Disconnect the server\'s console from a channel.",\n', '            },\n', '            "update":"Update the bot. This is a successor command of /replace.",\n', '            "announce":{\n', '                "embed":"Send text to discord with embed. Specify a md-formatted text file or a string as an argument.",\n', '            },\n', '            "status": "Display the status of the process.",\n', '        },\n', '    }\n', '\n', '    #今後も大きくなることが予想されるので、ここで条件分岐する\n', '    if lang == "ja":\n', '        send_help = "詳細なHelpはこちらを参照してください\\n<https://github.com/sleeping-mikan/server-bot-v2/blob/main/README.md>\\n"\n', '        RESPONSE_MSG = {\n', '            "other":{\n', '                "no_permission":"管理者権限を持っていないため実行できません",\n', '                "is_running":"サーバーが起動しているため実行できません",\n', '                "is_not_running":"サーバーが起動していないため実行できません",\n', '            },\n', '            "stop":{\n', '                "success":"サーバーを停止します",\n', '            },\n', '            "start":{\n', '                "success":"サーバーを起動します",\n', '            },\n', '            "cmd":{\n', '                "serverin":{\n', '                    "skipped_cmd":"コマンドが存在しない、または許可されないコマンドです",\n', '                    "unicode_encode_error": "コマンドに不正な文字が含まれています(指定された文字コードに含まれない文字が利用されています。)",\n', '                },\n', '                "stdin":{\n', '                    "invalid_path": "パス`{}`は不正/操作不可能な領域です",\n', '                    "not_file": "`{}`はファイルではありません",\n', '                    "permission_denied":"`{}`を操作する権限がありません",\n', '                    "file_size_limit":"サイズ`{}`は制限`{}`を超えている可能性があるためFile.ioにアップロードします\\nアップロード後に再度メンションで通知します",\n', '                    "file_size_limit_web":"サイズ`{}`は制限`{}`を超えているのでアップロードできません",\n', '                    "mk":{\n', '                        "success":"ファイル`{}`を作成または上書きしました",\n', '                        "is_link":"`{}`はシンボリックリンクであるため書き込めません",\n', '                        "is_directory":"`{}`はディレクトリであるため書き込めません",\n', '                    },\n', '                    "rm":{\n', '                        "success":"`{}`を削除しました",\n', '                        "file_not_found":"`{}`は見つかりません",\n', '                    },\n', '                    "ls":{\n', '                        "not_directory":"`{}`はディレクトリではありません",\n', '                        "file_not_found":"`{}`は見つかりません",\n', '                        "success":"`{}`\\n```ansi\\n{}```\\n",\n', '                        "to_long": "内容が2000文字を超えたためファイルに変換します。",\n', '                    },\n', '                    "mkdir":{\n', '                        "success":"ディレクトリ`{}`を作成しました",\n', '                        "exists":"`{}`は既に存在します",\n', '                    },\n', '                    "rmdir":{\n', '                        "success":"ディレクトリ`{}`を削除しました",\n', '                        "not_directory":"`{}`はディレクトリではありません",\n', '                        "not_exists":"`{}`は見つかりません",\n', '                    },\n', '                    "mv":{\n', '                        "success":"`{}`を`{}`に移動しました",\n', '                        "not_exists":"`{}`は見つかりません",\n', '                    },\n', '                    "send-discord":{\n', '                        "success":"<@{}> {} にファイルを送信しました",\n', '                        "file_io_error":"<@{}> File.ioへのアップロードに失敗しました status -> `{}` , reason -> `{}` :: `{}`",\n', '                        "file_not_found":"`{}`は見つかりません",\n', '                        "not_file":"`{}`はファイルではありません",\n', '                        "is_zip":"`{}`はディレクトリであるためzipで圧縮します",\n', '                        "is_file":"`{}`はファイルであるため送信します",\n', '                        "timeout":"<@{}> {} 秒を超えたため、送信を中断しました",\n', '                        "raise_error":"<@{}> 送信中にエラーが発生しました\\n```ansi\\n{}```",\n', '                        "send_myserver_link": "<@{}> {} から、{}をダウンロードできます。有効期限は5分です。",\n', '                        "send_capacity_error": "<@{}> 容量{}は制限容量{}を超えているため、送信できません。",\n', '                    },\n', '                    "wget":{\n', '                        "download_failed":"`{}`からファイルをダウンロードできません",\n', '                        "download_success":"`{}`からファイルを{}にダウンロードしました",\n', '                        "already_exists":"`{}`は既に存在します",\n', '                    },\n', '                }\n', '            },\n', '            "backup":{\n', '                "now_backup":"ファイルをコピー中・・・",\n', '                "success":"ファイルコピーが完了しました！",\n', '                "create":{\n', '                    "data_not_found":"データが見つかりません",\n', '                    "path_not_allowed":"許可されないパス",\n', '                },\n', '                "apply":{\n', '                    "path_not_found":"指定されたパスが見つかりません",\n', '                    "path_not_allowed":"許可されないパス",\n', '                },\n', '            },\n', '            # "replace":{\n', '            #     "not_allow":{"name":"このコマンドはconfigにより実行を拒否されました","value":"/replaceは現在のバージョンでは非推奨です\\nautoupdate機能による起動時自動更新と/updateによる更新を使用してください"},\n', '            #     "progress":"更新プログラムの適応中・・・",\n', '            # },\n', '            "ip":{\n', '                "not_allow":"このコマンドはconfigにより実行を拒否されました",\n', '                "get_ip_failed":"IPアドレスを取得できません",\n', '                "msg_startwith":"サーバーIP : "\n', '            },\n', '            "logs":{\n', '                "cant_access_other_dir":"他のディレクトリにアクセスすることはできません。この操作はログに記録されます。",\n', '                "not_found":"指定されたファイルが見つかりません。この操作はログに記録されます。",\n', '            },\n', '            "exit":{\n', '                "success":"botを終了します...",\n', '            },\n', '            "error":{\n', '                "error_base":"エラーが発生しました。\\n",\n', '            },\n', '            "permission":{\n', '                "success":"{} の権限 : \\n実行可能ディレクトリへの操作 : {} \\ndiscord管理者権限 : {}\\nbot管理者権限 : {}",\n', '                "change":{\n', '                    "already_added":"このユーザーはすでにbotの管理者権限を持っています",\n', '                    "add_success":"`{}`にbotの管理者権限を与えました",\n', '                    "remove_success":"`{}`からbotの管理者権限を剥奪しました",\n', '                    "already_removed":"このユーザーはbotの管理者権限を持っていません",\n', '                    "invalid_level":"権限レベルには削除(0)または1-{}の整数を指定してください。(指定された値 : `{}`)",\n', '                },\n', '            },\n', '            "lang":{\n', '                "success":"言語を{}に変更しました",\n', '            },\n', '            "tokengen":{\n', '                "success":"生成したトークン(30日間有効) : {}",\n', '            },\n', '            "terminal":{\n', '                "success":"サーバーのコンソールを{}に設定しました。",\n', '            },\n', '            "update":{\n', '                "same":"存在するファイルは既に最新です",\n', '                "different":"コミットidが異なるため更新を行います",\n', '                "download_failed":"更新のダウンロードに失敗しました",\n', '                "replace":"ch_id {}\\nmsg_id {}",\n', '                "force":"forceオプションが指定されたため、コミットidに関わらず更新を行います。",\n', '            },\n', '            "announce":{\n', '                "embed":{\n', '                    "exist_file_and_txt":"`{}`と`{}`は両方存在するため、送信できません",\n', '                    "empty":"`{}`は空のため、送信できません",\n', '                    "success":"データを送信しました",\n', '                    "replace_slash_n": "テキスト形式のデータに\\\\\\\\nが存在したため\\\\nに変換しました",\n', '                    "decode_error":"`{}`の読み込みに失敗しました",\n', '                },\n', '            },\n', '            "status": {\n', '                "mem_title": "メモリ使用量",\n', '                "mem_value": "**{} MB** Self",\n', '                "mem_server_value": "**{} MB** Server",\n', '                "cpu_title": "CPU使用率",\n', '                "cpu_value_thread": "**{}%** Thread {}",\n', '                "cpu_value_proc": "**{}%** Process {}",\n', '                "online_title": "オンライン状態",\n', '                "online_value": "{} Main Server\\n{} Uvicorn Server\\n{} Bot",\n', '                "base_title": "基本情報",\n', '                "base_value": "OS：**{}**\\nPython：**{}**\\nBot Version：**{}**",\n', '            },\n', '        }\n', '        ACTIVITY_NAME = {\n', '            "starting":"さーばーきどう",\n', '            "running":"さーばーじっこう",\n', '            "ending":"さーばーおしまい",\n', '            "ended":"さーばーとじてる",\n', '        }\n', '    elif lang == "en":\n', '        send_help = "Details on the help can be found here\\n<https://github.com/sleeping-mikan/server-bot-v2/blob/main/README.md>\\n"\n', '        RESPONSE_MSG = {\n', '            "other":{\n', '                "no_permission":"Permission denied",\n', '                "is_running":"Server is still running",\n', '                "is_not_running":"Server is not running",\n', '            },\n', '            "stop":{\n', '                "success":"The server has been stopped",\n', '            },\n', '            "start":{\n', '                "success":"The server has been started",\n', '            },\n', '            "cmd":{\n', '                "serverin":{\n', '                    "skipped_cmd":"The command is not found or not allowed",\n', '                    "unicode_encode_error":"Failed to execute command due to UnicodeEncodeError(A character that is not included in the specified character code is used.)",\n', '                },\n', '                "stdin":{\n', '                    "invalid_path": "`{}` is an invalid/operable area",\n', '                    "not_file": "`{}` is not a file",\n', '                    "permission_denied": "`{}` cannot be modified because it is an important file",\n', '                    "file_size_limit": "Upload to File.io because the file size of `{}` is over the limit of {} bytes\\nmention to you if ended",\n', '                    "file_size_limit_web" : "Cannot upload to File.io because the file size of `{}` is over the limit of {} bytes",\n', '                    "mk":{\n', '                        "success":"`{}` has been created or overwritten",\n', '                        "is_link": "`{}` is a symbolic link and cannot be written",\n', '                        "is_directory": "`{}` is a directory and cannot be written",\n', '                    },\n', '                    "rm":{\n', '                        "success":"`{}` has been deleted",\n', '                        "file_not_found":"`{}` not found",\n', '                    },\n', '                    "ls":{\n', '                        "not_directory":"`{}` is not a directory",\n', '                        "file_not_found":"`{}` not found",\n', '                        "success":"`{}`\\n```ansi\\n{}```\\n",\n', '                        "to_long": "The content is over 2000 characters and will be converted to a file.",\n', '                    },\n', '                    "mkdir":{\n', '                        "success":"Directory `{}` has been created",\n', '                        "exists":"`{}` already exists",\n', '                    },\n', '                    "rmdir":{\n', '                        "success":"Directory `{}` has been deleted",\n', '                        "not_directory":"`{}` is not a directory",\n', '                        "not_exists":"`{}` not found",\n', '                    },\n', '                    "mv":{\n', '                        "success":"`{}` has been moved to `{}`",\n', '                        "file_not_found":"`{}` not found",\n', '                    },\n', '                    "send-discord":{\n', '                        "success":"<@{}> Sent to {} a file",\n', '                        "file_io_error":"<@{}> File.io upload failed status -> `{}` , reason -> `{}` :: `{}`",\n', '                        "not_file":"`{}` is not a file",\n', '                        "file_not_found":"`{}` not found",\n', '                        "is_zip":"`{}` is a directory, so it will be compressed and sent to discord",\n', '                        "is_file":"`{}` is a file, so it will be sent to discord",\n', '                        "send_myserver_link": "<@{}> Sent to {} a file link -> `{}`",\n', '                        "send_capacity_error": "<@{}> The file size of `{}` is over the limit of {} bytes and cannot be sent to discord",\n', '                    },\n', '                    "wget":{\n', '                        "download_failed":"Download failed url:{}",\n', '                        "download_success":"Download complete url:{} path:{}",\n', '                        "already_exists":"`{}` already exists",\n', '                    }\n', '                }\n', '            },\n', '            "backup":{\n', '                "now_backup":"File copy in progress",\n', '                "success":"File copy complete!",\n', '                "create":{\n', '                    "data_not_found":"Data not found",\n', '                    "path_not_allowed":"Path not allowed",\n', '                },\n', '                "apply":{\n', '                    "path_not_found":"Path is not exists",\n', '                    "path_not_allowed":"Path not allowed",\n', '                },\n', '            },\n', '            # "replace":{\n', '            #     "not_allow":{"name":"This command is denied by config","value":"/replace is not recommended in now version. Please use auto update in config and /update"},\n', '            #     "progress":"Applying update program",\n', '            # },\n', '            "ip":{\n', '                "not_allow":"This command is denied by config",\n', '                "get_ip_failed":"Failed to get IP address",\n', '                "msg_startwith":"Server IP : "\n', '            },\n', '            "logs":{\n', '                "cant_access_other_dir":"Cannot access other directory. This operation will be logged.",\n', '                "not_found":"The specified file was not found. This operation will be logged.",\n', '            },\n', '            "exit":{\n', '                "success":"The bot is exiting...",\n', '            },\n', '            "error":{\n', '                "error_base":"An error has occurred.\\n",\n', '            },\n', '            "permission":{\n', '                "success":"{}\'s permission : \\nadvanced(root) features : {}\\ndiscord administrator permission : {}\\nbot administrator permission : {}",\n', '                "change":{\n', '                    "already_added":"The user has already been added as an administrator",\n', '                    "add_success":"Added as an administrator to {}",\n', '                    "already_removed":"The user has already been removed as an administrator",\n', '                    "remove_success":"Removed as an administrator from {}",\n', '                    "invalid_level":"Please specify an integer between 0 and {} for the permission level. (specified value : `{}`)",\n', '                },\n', '            },\n', '            "lang":{\n', '                "success":"Language changed to {}",\n', '            },\n', '            "tokengen":{\n', '                "success":"Generated token (valid for 30 days) : {}",\n', '            },\n', '            "terminal":{\n', '                "success":"The terminal has been set to {}",\n', '            },\n', '            "update":{\n', '                "same":"The same version is already installed",\n', '                "different":"The commit id is different to update",\n', '                "download_failed":"Download failed",\n', '                "replace":"ch_id {}\\nmsg_id {}",\n', '                "force":"update server.py because force option is true",\n', '            },\n', '            "announce":{\n', '                "embed":{\n', '                    "exist_file_and_txt":"File and text cannot be written at the same time",\n', '                    "empty":"Text cannot be empty",\n', '                    "decode_error":"Failed to decode file",\n', '                    "success": "File has been sent",\n', '                    "replace_slash_n": "found \\\\n, replaced to \\\\r\\\\n",\n', '                }\n', '            },\n', '            "status": {\n', '                "mem_title": "Memory Usage",\n', '                "mem_value": "**{} MB** Self",\n', '                "mem_server_value": "**{} MB** Server",\n', '                "cpu_title": "CPU Usage",\n', '                "cpu_value_thread": "**{}%** Thread {}",\n', '                "cpu_value_proc": "**{}%** Process {}",\n', '                "online_title": "Online Status",\n', '                "online_value": "{} Main Server\\n{} Uvicorn Server\\n{} Bot",\n', '                "base_title": "Basic Information",\n', '                "base_value": "OS: **{}**\\nPython: **{}**\\nBot Version: **{}**"\n', '            }\n', '        }\n', '        ACTIVITY_NAME = {\n', '            "starting":"Server go!",\n', '            "running":"Server whoosh!",\n', '            "ending":"Server stopping!",\n', '            "ended":"Server stop!",\n', '        }\n', '    def make_send_help():\n', '        global send_help\n', '        send_help += f"web : http://{requests.get(\'https://api.ipify.org\').text}:{web_port}\\n" \n', '        embed = ModifiedEmbeds.DefaultEmbed(title="How to use this bot")\n', '        for key in HELP_MSG[lang]:\n', '            embed.add_field(name=key,value=HELP_MSG[lang][key],inline=False)\n', '        embed.add_field(name="detail",value=send_help,inline=False)\n', '        send_help = embed\n', '    make_send_help()\n', '\n', '\n', 'get_text = asyncio.run(get_text_dat())\n', "sys_logger.info('create text data')\n"], '\n', '# util関数のロード\n', ['', '', '', '', '', '', '\n', 'async def not_enough_permission(interaction: discord.Interaction,logger: logging.Logger) -> bool:\n', "    logger.error('permission denied')\n", '    embed = ModifiedEmbeds.ErrorEmbed(title=RESPONSE_MSG["other"]["no_permission"])\n', '    await interaction.response.send_message(embed = embed,ephemeral = True)\n', '\n', '\n', 'async def is_administrator(user: discord.User) -> bool:\n', '    if not user.guild_permissions.administrator:\n', '        return False\n', '    return True\n', '\n', 'async def is_force_administrator(user: discord.User) -> bool:\n', '    #user idがforce_adminに含まれないなら\n', '    if user.id not in config["discord_commands"]["admin"]["members"]:\n', '        return False\n', '    return True\n', '\n', '#既にサーバが起動しているか\n', 'def is_running_server(logger: logging.Logger) -> bool:\n', '    global process\n', '    if process is not None:\n', "        logger.error('server is still running')\n", '        return True\n', '    return False\n', '\n', '#サーバーが閉まっている状態か\n', 'def is_stopped_server(logger: logging.Logger) -> bool:\n', '    global process\n', '    if process is None:\n', "        logger.error('server is not running')\n", '        return True\n', '    return False\n', '\n', 'async def reload_config():\n', '    import json\n', "    with open(config_file_place, 'r') as f:\n", '        global config\n', '        config = json.load(f)\n', '        #TODO\n', '    \n', '\n', 'async def rewrite_config(config: dict) -> bool:\n', '    try:\n', "        with open(config_file_place, 'w') as f:\n", '            json.dump(config, f,indent=4, ensure_ascii=False)\n', '        return True\n', '    except:\n', '        return False\n', '\n', '\n', 'async def dircp_discord(src, dst, interaction: discord.Interaction, embed: ModifiedEmbeds.DefaultEmbed, symlinks=False) -> None:\n', '    global exist_files, copyed_files\n', '    """\n', '    src : コピー元dir\n', '    dst : コピー先dir\n', '    symlinks : リンクをコピーするか\n', '    """\n', '    original_src = src\n', '    original_dst = dst\n', '    #表示サイズ\n', '    bar_width = 30\n', '    #送信制限\n', '    max_send = 20\n', '    # dstがbackuppathの場合だけ名前を操作する\n', '    if dst.startswith(backup_path):\n', '        dst = os.path.join(dst,datetime.now().strftime(\'%Y-%m-%d_%H_%M_%S\') + "-" + os.path.basename(src))\n', '    exist_files = 0\n', '    for root, dirs, files in os.walk(top=src, topdown=False):\n', '        exist_files += len(files)\n', '    #何ファイルおきにdiscordへ送信するか(最大100回送信するようにする)\n', '    send_sens = int(exist_files / max_send) if exist_files > max_send else 1\n', '    copyed_files = 0\n', '    async def copytree(src, dst, symlinks=False):\n', '        global copyed_files\n', '        names = os.listdir(src)\n', '        if not os.path.exists(dst):\n', '            os.makedirs(dst)\n', '        errors = []\n', '        for name in names:\n', '            srcname = os.path.join(src, name)\n', '            dstname = os.path.join(dst, name)\n', '            try:\n', '                if symlinks and os.path.islink(srcname):\n', '                    linkto = os.readlink(srcname)\n', '                    os.symlink(linkto, dstname)\n', '                elif os.path.isdir(srcname):\n', '                    await copytree(srcname, dstname, symlinks)\n', '                else:\n', '                    copy2(srcname, dstname)\n', '                    copyed_files += 1\n', '                    if copyed_files % send_sens == 0 or copyed_files == exist_files:\n', '                        now = RESPONSE_MSG["backup"]["now_backup"]\n', '                        if copyed_files == exist_files:\n', '                            now = RESPONSE_MSG["backup"]["success"]\n', '                        embed.clear_fields()\n', '                        embed.add_field(name = f"{now}",value=f"copy {original_src} -> {original_dst}\\n```{int((copyed_files / exist_files * bar_width) - 1) * \'=\'}☆{((bar_width) - int(copyed_files / exist_files * bar_width)) * \'-\'}  ({\'{: 5}\'.format(copyed_files)} / {\'{: 5}\'.format(exist_files)}) {\'{: 3.3f}\'.format(copyed_files / exist_files * 100)}%```", inline = False)\n', '                        await interaction.edit_original_response(embed=embed)\n', '            except OSError as why:\n', '                errors.append((srcname, dstname, str(why)))\n', '            # catch the Error from the recursive copytree so that we can\n', '            # continue with other files\n', '            except Error as err:\n', '                errors.extend(err.args[0])\n', '        try:\n', '            copystat(src, dst)\n', '        except OSError as why:\n', "            # can't copy file access times on Windows\n", '            if why.winerror is None:\n', '                errors.extend((src, dst, str(why)))\n', '        if errors:\n', '            raise Error(errors)\n', '    await copytree(src, dst, symlinks)\n', '    \n', '#logger thread\n', 'def server_logger(proc:subprocess.Popen,ret):\n', '    global process,is_back_discord , use_stop\n', '    if log["server"]:\n', '        file = open(file = server_path + "logs/server " + datetime.now().strftime("%Y-%m-%d_%H_%M_%S") + ".log",mode = "w", encoding="utf-8")\n', '    while True:\n', '        try:\n', '            logs = proc.stdout.readline()\n', '        except Exception as e:\n', '            sys_logger.error(e)\n', '            continue\n', '        # プロセスが終了している\n', "        if logs == '': \n", '            if proc.poll() is not None:\n', '                break\n', '            continue\n', '        #ログが\\nのみであれば不要\n', '        if logs == "\\n":\n', '            continue\n', '        #後ろが\\nなら削除\n', '        logs = logs.rstrip("\\n")\n', '        minecraft_logger.info(logs)\n', '        if log["server"]:\n', '            file.write(logs + "\\n")\n', '            file.flush()\n', '        if is_back_discord:\n', '            cmd_logs.append(logs)\n', '            is_back_discord = False\n', '    #サーバーが終了したことをログに残す\n', "    sys_logger.info('server is ended')\n", '    #もし、stop命令が見当たらないなら、エラー出力をしておく\n', '    if not use_stop:\n', "        sys_logger.error('stop command is not found')\n", '        use_stop = True\n', '    #プロセスを終了させる\n', '    process = None\n', '\n', 'async def print_user(logger: logging.Logger,user: discord.user):\n', "    logger.info('command used by ' + str(user))\n", '\n', 'class ServerBootException(Exception):pass\n', '\n', 'async def user_permission(user:discord.User):\n', '    # ユーザが管理者なら\n', '    if await is_administrator(user):\n', '        return USER_PERMISSION_MAX\n', '    # configに権限が書かれていないなら\n', '    if str(user.id) not in config["discord_commands"]["admin"]["members"]:\n', '        return 0\n', '    return config["discord_commands"]["admin"]["members"][str(user.id)]\n', '\n', '# 操作可能なパスかを確認\n', 'def is_path_within_scope(path):\n', '    # 絶対パスを取得\n', '    path = os.path.abspath(path)\n', '    resolved_target_path = pathlib.Path(path).resolve(strict=False)\n', '    resolved_server_path = pathlib.Path(server_path).resolve()\n', '    try:\n', '        resolved_target_path.relative_to(resolved_server_path)\n', '        sys_logger.info("valid path -> " + path + f"[{resolved_target_path}]" + f"(server_path : {server_path}[{resolved_server_path}])")\n', '        return True\n', '    except ValueError:\n', '        sys_logger.info("invalid path -> " + path + f"[{resolved_target_path}]" + f"(server_path : {server_path}[{resolved_server_path}])")\n', '        return False\n', '\n', 'async def create_zip_async(file_path: str) -> tuple[io.BytesIO, int]:\n', '    """ディレクトリをZIP化し、非同期的に返す関数"""\n', '    loop = asyncio.get_event_loop()\n', '    zip_buffer = io.BytesIO()\n', '\n', '    def zip_task():\n', '        with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_STORED) as zipf:\n', '            for root, dirs, files in os.walk(file_path):\n', '                for file in files:\n', '                    full_file_path = os.path.join(root, file)\n', '                    zipf.write(full_file_path, os.path.relpath(full_file_path, file_path))\n', '        zip_buffer.seek(0)\n', '        return zip_buffer\n', '\n', '    # 非同期スレッドでZIP作成を実行\n', '    zip_buffer = await loop.run_in_executor(None, zip_task)\n', '    file_size = zip_buffer.getbuffer().nbytes\n', '    return zip_buffer, file_size\n', '\n', 'async def send_discord_message_or_followup(interaction: discord.Interaction, message: str = discord.utils.MISSING, file = discord.utils.MISSING):\n', '    if interaction.response.is_done():\n', '        await interaction.followup.send(message, file=file)\n', '    else:\n', '        await interaction.response.send_message(message, file=file)\n', '\n', 'async def send_discord_message_or_edit(interaction: discord.Interaction, message: str = discord.utils.MISSING, file = discord.utils.MISSING, embed = discord.utils.MISSING, ephemeral = False):\n', '    if interaction.response.is_done():\n', '        await interaction.edit_original_response(content=message, embed=embed, attachments=[file] if file is not discord.utils.MISSING else discord.utils.MISSING)\n', '    else:\n', '        await interaction.response.send_message(content=message, file=file, embed=embed, ephemeral=ephemeral)\n', '\n', '\n', 'async def parse_mimd(text: str):\n', '    first_title_flag = False\n', '    send_data = deque([{"name":"","value":""}])\n', '    origin_data = {"title": ""}\n', '    for line in text.split("\\n"):\n', '        parse_line = line\n', '        while parse_line.startswith(" "):\n', '            parse_line = parse_line[1:]\n', '        # #から始まる一文ならnameに\n', '        if parse_line[0] == "#":\n', '            send_data.append({"name":"","value":""})\n', '            send_data[-1]["name"] = parse_line[1:]\n', '        # タイトルの設定(先頭のみ有効)\n', '        elif parse_line.startswith("|title|") and not first_title_flag:\n', '            origin_data["title"] = parse_line[7:]\n', '            first_title_flag = True\n', '        # 何でもないテキストならデータをセット\n', '        else:\n', '            send_data[-1]["value"] += line\n', '    return send_data, origin_data\n', '\n', 'async def get_directory_size(path):\n', '    size = 0\n', '    for entry in os.scandir(path):\n', '        if entry.is_file():\n', '            size += entry.stat().st_size\n', '        elif entry.is_dir():\n', '            size += await get_directory_size(entry.path)\n', '    return size'], '\n', '# 読み込み結果の出力\n', ['', '', '', '', '', '\n', '#ローカルファイルの読み込み結果出力\n', 'sys_logger.info("bot instance root -> " + now_path)\n', 'sys_logger.info("server instance root -> " + server_path)\n', 'sys_logger.info("read token file -> " + now_path + "/" +".token")\n', 'sys_logger.info("read config file -> " + now_path + "/" +".config")\n', 'view_config = config.copy()\n', 'view_config["web"]["secret_key"] = "****"\n', 'sys_logger.info("config -> " + str(view_config))\n', 'if config_changed: sys_logger.info("added config because necessary elements were missing")'], '\n', '# 読み込み時関数/ループ関数/メッセージ受信時関数を定義\n', ['', '', '', '', '', '', '', '', '@tasks.loop(seconds=10)\n', 'async def update_loop():\n', '    global discord_terminal_item, discord_terminal_send_length, discord_loop_is_run\n', '    # discord_loop_is_runを確認(2回以上実行された場合は処理をしない)\n', '    if discord_loop_is_run: return\n', '    try:\n', '        discord_loop_is_run = True\n', '        with status_lock:\n', '            if process is not None:\n', '                await client.change_presence(activity=discord.Game(name=ACTIVITY_NAME["running"]))\n', '            else:\n', '                await client.change_presence(activity=discord.Game(name=ACTIVITY_NAME["ended"]))\n', '            # discord_log_msgにデータがあれば送信\n', '            # 送信が無効の場合\n', '            if where_terminal == False:\n', '                discord_log_msg.clear()\n', '                discord_loop_is_run = False\n', '                return\n', '            pop_flg = False\n', '            while len(discord_log_msg) > 0:\n', '                while len(discord_log_msg) > terminal_capacity:\n', '                    discord_log_msg.popleft()\n', '                    pop_flg = True\n', '                if pop_flg:\n', '                    await client.get_channel(where_terminal).send(f"データ件数が{terminal_capacity}件を超えたため以前のデータを破棄しました。より多くのログを出力するには.config内のterminal.capacityを変更してください。")\n', '                    pop_flg = False\n', '                if len(discord_log_msg[0]) >= 1900:\n', '                    discord_log_msg.popleft()\n', '                    raise Exception("message is too long(skipped)")\n', '                discord_terminal_send_length += len(discord_log_msg[0]) + 1\n', '                if discord_terminal_send_length >= 1900:\n', '                    # 送信処理(where_terminal chに送信)\n', '                    await client.get_channel(where_terminal).send("```ansi\\n" + \'\'.join(discord_terminal_item) + "\\n```")\n', '                    # discord_terminal_itemをリセット\n', '                    discord_terminal_item = deque()\n', '                    discord_terminal_send_length = len(discord_log_msg[0]) + 1\n', '                    # 連投を避けるためにsleep\n', '                    await asyncio.sleep(1)\n', '                discord_terminal_item.append(discord_log_msg.popleft() + "\\n")\n', '            # 残っていれば送信\n', '            if len(discord_terminal_item) > 0:\n', '                await client.get_channel(where_terminal).send("```ansi\\n" + \'\'.join(discord_terminal_item) + "\\n```")\n', '                discord_terminal_item = deque()\n', '                discord_terminal_send_length = 0\n', '        discord_loop_is_run = False\n', '    except Exception as e:\n', '        terminal_logger.error(e)\n', '        discord_loop_is_run = False\n', '\n', '# メッセージが送信されたときの処理\n', '@client.event\n', 'async def on_message(message: discord.Message):\n', '    try:\n', '        # ボット自身のメッセージは無視する\n', '        if message.author == client.user:\n', '            return\n', '        # terminal ch以外のメッセージは無視\n', '        if message.channel.id != where_terminal:\n', '            return\n', '        # 管理者以外をはじく\n', '        if not await is_administrator(message.author) and not await is_force_administrator(message.author):\n', '            await message.reply("permission denied")\n', '            return\n', '        # サーバーが閉じていたらはじく\n', '        if process is None or process.poll() is not None:\n', '            await message.reply("server is not running")\n', '            return\n', '        # コマンドを処理\n', '        cmd_list = message.content.split(" ")\n', '        # 許可されないコマンドをはじく\n', '        if message.author.bot is True: pass\n', '        elif cmd_list[0] not in allow_cmd:\n', '            sys_logger.error(\'unknown command : \' + " ".join(cmd_list))\n', '            await message.reply("this command is not allowed")\n', '            return\n', '        else:\n', '            process.stdin.write(message.content + "\\n")\n', '            process.stdin.flush()\n', '    except Exception as e:\n', '        sys_logger.error(e)\n', '\n', '@client.event\n', 'async def on_ready():\n', '    global process\n', "    ready_logger.info('discord bot logging on')\n", '    # update_loopを開始\n', '    update_loop.start()\n', '    # 拡張で読み込んだtasksを実行\n', '    for task in extension_tasks_func:\n', '        task.start()\n', '    try:\n', '        #サーバーの起動\n', '        await client.change_presence(activity=discord.Game(ACTIVITY_NAME["starting"]))\n', '        if process is  None:\n', '            #server を実行する\n', '            process = subprocess.Popen([server_path + server_name, *server_args],cwd=server_path,shell=True,stdin=subprocess.PIPE,stdout=subprocess.PIPE,encoding=server_char_code)\n', '            threading.Thread(target=server_logger,args=(process,deque())).start()\n', "            ready_logger.info('server starting')\n", '        else:\n', "            ready_logger.info('skip server starting because server already running')\n", '        # アクティビティを設定 \n', '        await client.change_presence(activity=discord.Game(ACTIVITY_NAME["running"])) \n', '        # スラッシュコマンドを同期 \n', '        await tree.sync()\n', '    except Exception as e:\n', '        sys_logger.error(f"error on ready -> {e}")'], '\n', '# 機能関数読み込み\n', ['\n', '', '', '', ['', '', '', '', '', '', '', '\n', '\n', '\n', '\n', 'def core_stop() -> str:\n', '    global process,use_stop\n', '    if is_stopped_server(stop_logger):\n', '        return RESPONSE_MSG["other"]["is_not_running"]\n', '    use_stop = True\n', "    stop_logger.info('server stopping')\n", '    process.stdin.write(STOP + "\\n")\n', '    process.stdin.flush()\n', '    return RESPONSE_MSG["stop"]["success"]\n', '\n', 'def core_start() -> str:\n', '    global process,use_stop\n', '    if is_running_server(start_logger):\n', '        return RESPONSE_MSG["other"]["is_running"]\n', "    start_logger.info('server starting')\n", '    process = subprocess.Popen([server_path + server_name, *server_args],cwd=server_path,shell=True,stdin=subprocess.PIPE,stdout=subprocess.PIPE,encoding=server_char_code)\n', '    threading.Thread(target=server_logger,args=(process,deque())).start()\n', '    return RESPONSE_MSG["start"]["success"]\n']], '\n', '# スラッシュコマンドを定義\n', ['', '', '', '', '', '', '', '', '', '', '', '', '\n', '\n', '#start\n', '@tree.command(name="start",description=COMMAND_DESCRIPTION[lang]["start"])\n', 'async def start(interaction: discord.Interaction):\n', '    await print_user(start_logger,interaction.user)\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["start"]: \n', '        await not_enough_permission(interaction,start_logger)\n', '        return\n', '    result = core_start()\n', '    embed = ModifiedEmbeds.DefaultEmbed(title = f"/start")\n', '    embed.add_field(name="",value=result,inline=False)\n', '    await interaction.response.send_message(embed=embed)\n', '    if result == RESPONSE_MSG["other"]["is_running"]:\n', '        return\n', '    await client.change_presence(activity=discord.Game(ACTIVITY_NAME["running"]))\n', '\n', '#/stop\n', '@tree.command(name="stop",description=COMMAND_DESCRIPTION[lang]["stop"])\n', 'async def stop(interaction: discord.Interaction):\n', '    global use_stop\n', '    await print_user(stop_logger,interaction.user)\n', '    global process\n', '    #管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["stop"]: \n', '        #両方not(権限がないなら)\n', '        await not_enough_permission(interaction,stop_logger)\n', '        return\n', '    result = core_stop()\n', '    embed = ModifiedEmbeds.DefaultEmbed(title = f"/stop")\n', '    embed.add_field(name="",value=result,inline=False)\n', '\n', '    await interaction.response.send_message(embed=embed)\n', '    if result == RESPONSE_MSG["other"]["is_not_running"]:\n', '        return\n', '    await client.change_presence(activity=discord.Game(ACTIVITY_NAME["ending"])) \n', '    while True:\n', '        #終了するまで待つ\n', '        if process is None:\n', '            await client.change_presence(activity=discord.Game(ACTIVITY_NAME["ended"])) \n', '            break\n', '        await asyncio.sleep(1)\n', '\n', ['', '', '', '', '', '', '', '', '\n', '# グループの設定\n', '# root\n', 'command_group_permission = app_commands.Group(name="permission",description="permission group")\n', '\n', '#/admin force <add/remove>\n', '@command_group_permission.command(name="change",description=COMMAND_DESCRIPTION[lang]["permission"]["change"])\n', 'async def change(interaction: discord.Interaction,level: int,user:discord.User):\n', '    await print_user(admin_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title = f"/permission change {level} {user}")\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["permission change"]:\n', '        await not_enough_permission(interaction,lang_logger)\n', '        return\n', '    async def read_force_admin():\n', '        global bot_admin\n', '        bot_admin = config["discord_commands"]["admin"]["members"]\n', '    # 権限レベル1~4を付与\n', '    if level >= 1 and level <= USER_PERMISSION_MAX:\n', '        if user.id in config["discord_commands"]["admin"]["members"]:\n', '            embed.add_field(name="",value=RESPONSE_MSG["permission"]["change"]["already_added"],inline=False)\n', '            await interaction.response.send_message(embed=embed)\n', '            return\n', '        config["discord_commands"]["admin"]["members"][str(user.id)] = level\n', '        #configファイルを変更する\n', '        await rewrite_config(config)\n', '        await read_force_admin()\n', '        embed.add_field(name="",value=RESPONSE_MSG["permission"]["change"]["add_success"].format(user),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        admin_logger.info(f"exec force admin add {user}")\n', '    elif level == 0:\n', '        if user.id not in config["discord_commands"]["admin"]["members"]:\n', '            embed.add_field(name="",value=RESPONSE_MSG["permission"]["change"]["already_removed"],inline=False)\n', '            await interaction.response.send_message(embed=embed)\n', '            return\n', '        config["discord_commands"]["admin"]["members"].pop(str(user.id))\n', '        #configファイルを変更する\n', '        await rewrite_config(config)\n', '        await read_force_admin()\n', '        embed.add_field(name="",value=RESPONSE_MSG["permission"]["change"]["remove_success"].format(user),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        admin_logger.info(f"exec force admin remove {user}")\n', '    else:\n', '        embed.add_field(name="",value=RESPONSE_MSG["permission"]["change"]["invalid_level"].format(USER_PERMISSION_MAX,level),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        admin_logger.info("invalid level")\n', '\n', '#/permission <user>\n', '@command_group_permission.command(name="view",description=COMMAND_DESCRIPTION[lang]["permission"]["view"])\n', 'async def view(interaction: discord.Interaction,user:discord.User,detail:bool):\n', '    await print_user(permission_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title = f"/permission view {user} {detail}")\n', '    COMMAND_MAX_LENGTH = max([len(key) for key in COMMAND_PERMISSION])\n', '    advanced = "☑" if enable_advanced_features else "☐"\n', '    value = {"admin":"☐","force_admin":"☐"}\n', '    if await is_administrator(user): value["admin"] = f"☑({USER_PERMISSION_MAX})"\n', '    value["force_admin"] = await user_permission(user)\n', '    if detail:\n', '        my_perm_level = await user_permission(user)\n', '        can_use_cmd = {f"{key}":("☑" if COMMAND_PERMISSION[key] <= my_perm_level else "☐") + f"({COMMAND_PERMISSION[key]})" for key in COMMAND_PERMISSION}\n', '        embed.add_field(name="",value=RESPONSE_MSG["permission"]["success"].format(user,advanced,value["admin"],value["force_admin"]) + "\\n```\\n"+"\\n".join([f"{key.ljust(COMMAND_MAX_LENGTH)} : {value}" for key,value in can_use_cmd.items()]) + "\\n```",inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '    else:\n', '        embed.add_field(name="",value=RESPONSE_MSG["permission"]["success"].format(user,advanced,value["admin"],value["force_admin"]),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '    permission_logger.info("send permission info : " + str(user.id) + f"({user})")\n', '\n', 'tree.add_command(command_group_permission)'], '', '', '', '\n', '\n', '#/lang <lang>\n', '@tree.command(name="lang",description=COMMAND_DESCRIPTION[lang]["lang"])\n', '@app_commands.choices(\n', '    language = [\n', '        app_commands.Choice(name="en",value="en"),\n', '        app_commands.Choice(name="ja",value="ja"),\n', '    ]\n', ')\n', 'async def language(interaction: discord.Interaction,language:str):\n', '    """\n', '    config の lang を変更する\n', '    permission : discord 管理者 (2)\n', '    lang : str "en"/"ja"\n', '    """\n', '    await print_user(lang_logger,interaction.user)\n', '    global lang\n', '    #管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["lang"]:\n', '        await not_enough_permission(interaction,lang_logger)\n', '        return\n', '    #データの書き換え\n', '    config["discord_commands"]["lang"] = language\n', '    lang = config["discord_commands"]["lang"]\n', '    #configファイルを変更する\n', '    await rewrite_config(config)\n', '    #textデータを再構築\n', '    await get_text_dat()\n', '    embed = ModifiedEmbeds.DefaultEmbed(title = f"/lang {language}")\n', '    embed.add_field(name="",value=RESPONSE_MSG["lang"]["success"].format(language))\n', '    await interaction.response.send_message(embed=embed)\n', '    lang_logger.info("change lang to " + lang)\n', '\n', '#/cmd serverin <server command>\n', '#/cmd stdin \n', '\n', ['\n', '\n', '\n', ['', '', '', '', '\n', '# グループの設定\n', '# root\n', 'command_group_cmd = app_commands.Group(name="cmd",description="cmd group")\n', '\n', 'serverin_logger = cmd_logger.getChild("serverin")'], '\n', ['', '', '', '', '', '', '', '', '', '\n', '\n', '\n', '@command_group_cmd.command(name="serverin",description=COMMAND_DESCRIPTION[lang]["cmd"]["serverin"])\n', 'async def cmd(interaction: discord.Interaction,command:str):\n', '    await print_user(serverin_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/cmd serverin {command}")\n', '    global is_back_discord,cmd_logs\n', '    #管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd serverin"]: \n', '        await not_enough_permission(interaction,serverin_logger)\n', '        return\n', '    #サーバー起動確認\n', '    if is_stopped_server(serverin_logger): \n', '        serverin_logger.info("is not running")\n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_not_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    #コマンドの利用許可確認\n', '    if command.split()[0] not in allow_cmd:\n', "        serverin_logger.error('unknown command : ' + command)\n", '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["serverin"]["skipped_cmd"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    serverin_logger.info("run command : " + command)\n', '    try:\n', '        process.stdin.write(command + "\\n")\n', '    except UnicodeEncodeError:\n', '        serverin_logger.error(f"UnicodeEncodeError({command})")\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["serverin"]["unicode_encode_error"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    process.stdin.flush()\n', '    #結果の返却を要求する\n', '    is_back_discord = True\n', '    #結果を送信できるまで待機\n', '    while True:\n', '        #何もなければ次を待つ\n', '        if len(cmd_logs) == 0:\n', '            await asyncio.sleep(0.1)\n', '            continue\n', '        embed.add_field(name="",value=cmd_logs.popleft(),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        break'], '\n', '\n', ['', '', '', '', '', '', '', '', '', '\n', 'stdin_logger = cmd_logger.getChild("stdin")\n', '\n', '#サブグループstdinを作成\n', 'command_group_cmd_stdin = app_commands.Group(name="stdin",description="stdin group")\n', '# サブグループを設定\n', 'command_group_cmd.add_command(command_group_cmd_stdin)\n', '\n', '\n', 'important_bot_file = [\n', '    pathlib.Path(os.path.abspath(os.path.join(os.path.dirname(__file__),i))).resolve() for i in sys_files\n', '] + [\n', '    pathlib.Path(os.path.join(server_path,i)).resolve() for i in sys_files\n', ']\n', '\n', '\n', '\n', '# 重要ファイルでないか(最高権限要求するようなファイルかを確認)\n', 'async def is_important_bot_file(path):\n', '    # 絶対パスを取得\n', '    path = pathlib.Path(os.path.abspath(path)).resolve()\n', '    # 重要ファイルの場合はTrueを返す\n', '    for f in important_bot_file:\n', '        if path == f or path.is_relative_to(f):\n', '            return True\n', '    return False'], ['', '', '', '\n', '\n', 'stdin_ls_logger = stdin_logger.getChild("ls")\n', '@command_group_cmd_stdin.command(name="ls",description=COMMAND_DESCRIPTION[lang]["cmd"]["stdin"]["ls"])\n', 'async def ls(interaction: discord.Interaction, file_path: str):\n', '    await print_user(stdin_ls_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/cmd stdin ls {file_path}")\n', '    # 管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd stdin ls"]:\n', '        await not_enough_permission(interaction,stdin_ls_logger)\n', '        return\n', '    # server_path + file_path 閲覧パスの生成\n', '    file_path = os.path.abspath(os.path.join(server_path,file_path))\n', '    # 操作可能なパスか確認\n', '    if not is_path_within_scope(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["invalid_path"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_ls_logger.info("invalid path -> " + file_path)\n', '        return\n', '    # 対象が存在するか\n', '    if not os.path.exists(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["ls"]["file_not_found"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_ls_logger.info("file not found -> " + file_path)\n', '        return\n', '    # 対象がディレクトリであるか\n', '    if not os.path.isdir(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["ls"]["not_directory"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_ls_logger.info("not directory -> " + file_path)\n', '        return\n', '    # lsコマンドを実行\n', '    files = os.listdir(file_path)\n', '\n', '    colorized_files = deque()\n', '    \n', '    for f in files:\n', '        full_path = os.path.join(file_path, f)\n', '        if os.path.isdir(full_path):\n', '            # ディレクトリは青色\n', '            colorized_files.append(f"\\033[34m{f}\\033[0m")\n', '        elif os.path.islink(full_path):\n', '            # シンボリックリンクは紫\n', '            colorized_files.append(f"\\033[35m{f}\\033[0m")\n', '        else:\n', '            # 通常ファイルは緑\n', '            colorized_files.append(f"\\033[32m{f}\\033[0m")\n', '    formatted_files = "\\n".join(colorized_files)\n', '    stdin_ls_logger.info("list directory -> " + file_path)\n', '    if len(formatted_files) > 900:\n', '            with io.StringIO() as temp_file:\n', '                temp_file.write("\\n".join(files))\n', '                temp_file.seek(0)\n', '                # Discordファイルオブジェクトに変換して送信\n', '                discord_file = discord.File(temp_file, filename="directory_list.txt")\n', '                embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["ls"]["to_long"].format(file_path),inline=False)\n', '                await interaction.response.send_message(\n', '                    embed=embed,\n', '                    file=discord_file\n', '                )\n', '    else:\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["ls"]["success"].format(file_path,formatted_files),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n'], ['', '', '', '\n', 'stdin_mk_logger = stdin_logger.getChild("mk")\n', '\n', '# 以下のコマンドはserver_pathを起点としてそれ以下のファイルを操作する\n', '# ファイル送信コマンドを追加\n', '@command_group_cmd_stdin.command(name="mk",description=COMMAND_DESCRIPTION[lang]["cmd"]["stdin"]["mk"])\n', 'async def mk(interaction: discord.Interaction, file_path: str,file:discord.Attachment|None = None):\n', '    await print_user(stdin_mk_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/cmd stdin mk {file_path} {file.filename if file is not None else \'\'}")\n', '    # 管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd stdin mk"]:\n', '        await not_enough_permission(interaction,stdin_mk_logger)\n', '        return\n', '    #サーバー起動確認\n', '    if is_running_server(stdin_mk_logger): \n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # server_path + file_path にファイルを作成\n', '    file_path = os.path.abspath(os.path.join(server_path,file_path))\n', '    # 操作可能なパスか確認\n', '    if not is_path_within_scope(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["invalid_path"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mk_logger.info("invalid path -> " + file_path)\n', '        return\n', '    # ファイルがリンクであれば拒否\n', '    if os.path.islink(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["mk"]["is_link"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mk_logger.info("file is link -> " + file_path)\n', '        return\n', '    #ディレクトリであれば拒否\n', '    if os.path.isdir(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["mk"]["is_directory"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mk_logger.info("file is directory -> " + file_path)\n', '        return\n', '    # 全ての条件を満たすがサーバー管理者権限を持たないまたは危険な操作を拒否されている状態で、重要ファイルを操作しようとしている場合\n', '    if ((not await is_administrator(interaction.user)) or not enable_advanced_features) and await is_important_bot_file(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["permission_denied"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mk_logger.info("permission denied -> " + file_path)\n', '        return\n', '    else:\n', '        # 空のファイルを作成\n', '        open(file_path,"w").close()\n', '        # ファイルをfile_pathに保存\n', '        if file is not None:\n', '            await file.save(file_path)\n', '    stdin_mk_logger.info("create file -> " + file_path)\n', '    embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["mk"]["success"].format(file_path),inline=False)\n', '    await interaction.response.send_message(embed=embed)\n'], ['', '', '', '\n', 'stdin_rm_logger = stdin_logger.getChild("rm")\n', '\n', '@command_group_cmd_stdin.command(name="rm",description=COMMAND_DESCRIPTION[lang]["cmd"]["stdin"]["rm"])\n', 'async def rm(interaction: discord.Interaction, file_path: str):\n', '    await print_user(stdin_rm_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title=f"/cmd stdin rm {file_path}")\n', '    # 管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd stdin rm"]:\n', '        await not_enough_permission(interaction,stdin_rm_logger)\n', '        return\n', '    #サーバー起動確認\n', '    if is_running_server(stdin_rm_logger): \n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # server_path + file_path のパスを作成\n', '    file_path = os.path.abspath(os.path.join(server_path,file_path))\n', '    # 操作可能なパスか確認\n', '    if not is_path_within_scope(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["invalid_path"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_rm_logger.info("invalid path -> " + file_path)\n', '        return\n', '    # ファイルが存在しているかを確認\n', '    if not os.path.exists(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["rm"]["file_not_found"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_rm_logger.info("file not found -> " + file_path)\n', '        return\n', '    # 該当のアイテムがファイルか\n', '    if not os.path.isfile(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["not_file"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_rm_logger.info("not file -> " + file_path)\n', '        return\n', '    # 全ての条件を満たすがサーバー管理者権限を持たず、重要ファイルを操作しようとしている場合\n', '    if (not await is_administrator(interaction.user) or not enable_advanced_features) and await is_important_bot_file(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["permission_denied"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_rm_logger.info("permission denied -> " + file_path)\n', '        return\n', '    # ファイルを削除\n', '    os.remove(file_path)\n', '    stdin_rm_logger.info("remove file -> " + file_path)\n', '    embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["rm"]["success"].format(file_path),inline=False)\n', '    await interaction.response.send_message(embed=embed)\n'], ['', '', '', '\n', 'stdin_mkdir_logger = stdin_logger.getChild("mkdir")\n', '\n', '@command_group_cmd_stdin.command(name="mkdir",description=COMMAND_DESCRIPTION[lang]["cmd"]["stdin"]["mkdir"])\n', 'async def mkdir(interaction: discord.Interaction, dir_path: str):\n', '    await print_user(stdin_mkdir_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/cmd stdin mkdir {dir_path}")\n', '    # 管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd stdin mkdir"]:\n', '        await not_enough_permission(interaction,stdin_mkdir_logger)\n', '        return\n', '    # server_path + file_path のパスを作成\n', '    dir_path = os.path.abspath(os.path.join(server_path,dir_path))\n', '    # 操作可能なパスか確認\n', '    if not is_path_within_scope(dir_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["invalid_path"].format(dir_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mkdir_logger.info("invalid path -> " + dir_path)\n', '        return\n', '    # 既に存在するか確認\n', '    if os.path.exists(dir_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["mkdir"]["exists"].format(dir_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mkdir_logger.info("directory already exists -> " + dir_path)\n', '        return\n', '    # ディレクトリを作成\n', '    os.makedirs(dir_path)\n', '    stdin_mkdir_logger.info("create directory -> " + dir_path)\n', '    embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["mkdir"]["success"].format(dir_path),inline=False)\n', '    await interaction.response.send_message(embed=embed)\n'], ['', '', '', '\n', 'stdin_rmdir_logger = stdin_logger.getChild("rmdir")\n', '\n', '@command_group_cmd_stdin.command(name="rmdir",description=COMMAND_DESCRIPTION[lang]["cmd"]["stdin"]["rmdir"])\n', 'async def rmdir(interaction: discord.Interaction, dir_path: str):\n', '    await print_user(stdin_rmdir_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/cmd stdin rmdir {dir_path}")\n', '    # 管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd stdin rmdir"]:\n', '        await not_enough_permission(interaction,stdin_rmdir_logger)\n', '        return\n', '    #サーバー起動確認\n', '    if is_running_server(stdin_rmdir_logger): \n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # server_path + file_path のパスを作成\n', '    dir_path = os.path.abspath(os.path.join(server_path,dir_path))\n', '    # 操作可能なパスか確認\n', '    if not is_path_within_scope(dir_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["invalid_path"].format(dir_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_rmdir_logger.info("invalid path -> " + dir_path)\n', '        return\n', '    # 既に存在するか確認\n', '    if not os.path.exists(dir_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["rmdir"]["not_exists"].format(dir_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_rmdir_logger.info("directory not exists -> " + dir_path)\n', '        return\n', '    # 全ての条件を満たすが、権限が足りず、対象が重要なディレクトリか確認\n', '    if await is_important_bot_file(dir_path) and (not enable_advanced_features or (not await is_administrator(interaction.user))):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["permission_denied"].format(dir_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_rmdir_logger.info("permission denied -> " + dir_path)\n', '        return\n', '    # ディレクトリを削除\n', '    rmtree(dir_path)\n', '    stdin_rmdir_logger.info("remove directory -> " + dir_path)\n', '    embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["rmdir"]["success"].format(dir_path),inline=False)\n', '    await interaction.response.send_message(embed=embed)\n'], ['', '', '', '\n', 'stdin_mv_logger = stdin_logger.getChild("mv")\n', '\n', '@command_group_cmd_stdin.command(name="mv",description=COMMAND_DESCRIPTION[lang]["cmd"]["stdin"]["mv"])\n', 'async def cmd_stdin_mv(interaction: discord.Interaction, path: str, dest: str):\n', '    await print_user(stdin_mv_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/cmd stdin mv {path} {dest} ")\n', '    # 権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd stdin mv"]:\n', '        await not_enough_permission(interaction,stdin_mv_logger)\n', '        return\n', '    #サーバー起動確認\n', '    if is_running_server(stdin_mv_logger): \n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mv_logger.info("server is running")\n', '        return\n', '    # server_path + path のパスを作成\n', '    path = os.path.abspath(os.path.join(server_path,path))\n', '    # server_path + dest のパスを作成\n', '    dest = os.path.abspath(os.path.join(server_path,dest))\n', '    # 操作可能なパスか確認\n', '    if not is_path_within_scope(path) or not is_path_within_scope(dest):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["invalid_path"].format(path,dest),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mv_logger.info("invalid path -> " + path + " or " + dest)\n', '        return\n', '    # ファイルが存在しているかを確認\n', '    if not os.path.exists(path):\n', '        embed.add_field(name="",velue=RESPONSE_MSG["cmd"]["stdin"]["mv"]["file_not_found"].format(path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mv_logger.info("file not found -> " + path)\n', '        return\n', '    # 該当のアイテムがファイルか\n', '    if not os.path.isfile(path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["not_file"].format(path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mv_logger.info("not file -> " + path)\n', '        return\n', '    # 全ての条件を満たすがサーバー管理者権限を持たず、重要ファイルを操作しようとしている場合\n', '    if (not await is_administrator(interaction.user) or not enable_advanced_features) and (await is_important_bot_file(path) or await is_important_bot_file(dest)):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["permission_denied"].format(path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_mv_logger.info("permission denied -> " + path + " or " + dest)\n', '        return\n', '    # ファイルを移動\n', '    shutil_move(path,dest)\n', '    stdin_mv_logger.info("move file -> " + path + " -> " + dest)\n', '    embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["mv"]["success"].format(path,dest),inline=False)\n', '    await interaction.response.send_message(embed=embed)'], ['', '', '', '\n', 'stdin_send_discord_logger = stdin_logger.getChild("send-discord")\n', '\n', '# # !open ./repos/discord/command/cmd/stdin/send_discord/fileio.py\n', ['', '', '', '', '\n', '\n', 'class SendDiscordSelfServer:\n', '    # クラススコープで状態を保持\n', '    _download_registry: dict[str, tuple[str, float]] = {}\n', '    _lock = asyncio.Lock()\n', '    _ttl_default = 300  # 5分\n', '\n', '    @classmethod\n', '    async def register_download(cls, directory_path: str, ttl_seconds: int = None) -> str:\n', '        # if not os.path.isdir(directory_path):\n', '        #     raise ValueError("指定されたパスはディレクトリではありません")\n', '        ttl = ttl_seconds if ttl_seconds else cls._ttl_default\n', '        token = uuid.uuid4().hex\n', '        expire_at = datetime.now() + timedelta(seconds=ttl)\n', '        # ファイル容量がbits_capacityを超えるなら、ダウンロード不可\n', '        if (dir_size := await get_directory_size(directory_path) if os.path.isdir(directory_path) else os.path.getsize(directory_path)) > send_discord_bits_capacity:\n', '            return False, [1, str(dir_size),str(send_discord_bits_capacity)]\n', '        async with cls._lock:\n', '            cls._download_registry[token] = (directory_path, expire_at)\n', '        stdin_send_discord_logger.info("register download -> " + directory_path + f"({dir_size} Bytes)")\n', '        return True, f"http://{requests.get(\'https://api.ipify.org\').text}:{web_port}/download/{token}"\n', '\n', '    @classmethod\n', '    async def _cleanup_loop(cls):\n', '        while True:\n', '            now = datetime.now()\n', '            async with cls._lock:\n', '                expired = [t for t, (_, exp) in cls._download_registry.items() if now > exp]\n', '                for t in expired:\n', '                    del cls._download_registry[t]\n', '                    stdin_send_discord_logger.info("cleanup download -> " + t)\n', '            await asyncio.sleep(30)\n', '\n', '    @classmethod\n', '    async def download(cls, token: str):\n', '        async with cls._lock:\n', '            entry = cls._download_registry.pop(token, None)\n', '        if not entry:\n', '            stdin_send_discord_logger.info("download not found -> " + token)\n', '            raise HTTPException(status_code=404, detail="リンクが無効または既に使用されました")\n', '        directory_path, expire_at = entry\n', '        if \tdatetime.now() > expire_at > expire_at:\n', '            stdin_send_discord_logger.info("download expired -> " + token)\n', '            raise HTTPException(status_code=410, detail="このリンクは期限切れです")\n', '\n', '        # zipstreamでリアルタイムZIP\n', '        z = zipstream.ZipStream()\n', '        z.add_path(directory_path)\n', '        # for root, _, files in os.walk(directory_path):\n', '        #     for file in files:\n', '        #         full_path = os.path.join(root, file)\n', '        #         arcname = os.path.relpath(full_path, start=directory_path)\n', '        #         z.add(, arcname)\n', '        stdin_send_discord_logger.info("download -> " + directory_path)\n', '        filename = os.path.basename(directory_path) or "download"\n', '        return StreamingResponse(\n', '            z,\n', '            media_type="application/zip",\n', '            headers={"Content-Disposition": f\'attachment; filename="{filename}.zip"\'}\n', '        )\n', '\n', '    @classmethod\n', '    def create_app(cls) -> FastAPI:\n', '        @asynccontextmanager\n', '        async def lifespan(app: FastAPI):\n', '            task = asyncio.create_task(cls._cleanup_loop())\n', '            yield\n', '            task.cancel()\n', '\n', '        app = FastAPI(lifespan=lifespan)\n', '        app.add_api_route("/download/{token}", cls.download, methods=["GET"])\n', '        return app\n'], ['', '', '', '', '', '', '\n', '@command_group_cmd_stdin.command(name="send-discord",description=COMMAND_DESCRIPTION[lang]["cmd"]["stdin"]["send-discord"])\n', 'async def send_discord(interaction: discord.Interaction, path: str):\n', '    await print_user(stdin_send_discord_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/cmd stdin send-discord {path}")\n', '    file_path = os.path.abspath(os.path.join(server_path,path))  # ファイルのパス\n', '    file_name = os.path.basename(file_path)\n', '    file_size_limit = 9 * 1024 * 1024  # 9MB\n', '    file_size_limit_web = send_discord_bits_capacity  # 2GBを超えた場合file.ioでも無理なのでエラー\n', '    # 権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd stdin send-discord"]:\n', '        await not_enough_permission(interaction,stdin_send_discord_logger)\n', '        return\n', '    # ファイルが存在しているかを確認\n', '    if not os.path.exists(file_path):\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["send-discord"]["file_not_found"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_send_discord_logger.info("file not found -> " + file_path)\n', '        return\n', '    # パスが許可されているかを確認 or .tokenなら常に拒否\n', '    if not is_path_within_scope(file_path) or os.path.basename(file_path) == ".token":\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["invalid_path"].format(file_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        stdin_send_discord_logger.info("invalid path -> " + file_path)\n', '        return\n', '    # if send_discord_mode == "fileio":\n', '    #     await send_discord_fileio(interaction, embed, stdin_send_discord_logger, file_size_limit_web, file_size_limit,file_path, file_name)\n', '    link = await SendDiscordSelfServer.register_download(file_path)\n', '    if link[0]:\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["send-discord"]["send_myserver_link"].format(interaction.user.id, link[1], file_path),inline=False)\n', '    else:\n', '        # エラーコードを読む\n', '        if link[1][0] == 1:\n', '            embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["send-discord"]["send_capacity_error"].format(interaction.user.id, link[1][1], link[1][2]),inline=False)\n', '    await interaction.response.send_message(embed=embed, ephemeral=True)']], ['', '', '', '\n', 'stdin_wget_logger = stdin_logger.getChild("wget")\n', '\n', '@command_group_cmd_stdin.command(name="wget",description=COMMAND_DESCRIPTION[lang]["cmd"]["stdin"]["wget"])\n', 'async def wget(interaction: discord.Interaction,url:str,path:str = "mi_dl_file.tmp"):\n', '    await print_user(stdin_wget_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/cmd stdin wget {url} {path} ")\n', '    # 権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["cmd stdin wget"]: \n', '        await not_enough_permission(interaction,stdin_wget_logger)\n', '        return\n', '    save_path = os.path.abspath(os.path.join(server_path,path))\n', '    # 既にファイルが存在しているか確認\n', '    if os.path.exists(save_path):\n', '        stdin_wget_logger.info("file already exists -> " + save_path)\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["wget"]["already_exists"].format(path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # pathが操作可能か確認\n', '    if not is_path_within_scope(save_path):\n', '        stdin_wget_logger.info("invalid path -> " + save_path)\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["invalid_path"].format(save_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # 管理者権限を持っていなくて、重要ファイルをダウンロードする場合は拒否\n', '    if (not await is_administrator(interaction.user) or not enable_advanced_features) and await is_important_bot_file(save_path):\n', '        stdin_wget_logger.info("permission denied -> " + save_path)\n', '        embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["permission_denied"].format(save_path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # URLからファイルをダウンロード\n', '    async with aiohttp.ClientSession() as session:\n', '        try:\n', '            async with session.get(url) as response:\n', '                if response.status != 200:\n', '                    stdin_wget_logger.info("download failed -> " + url)\n', '                    embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["wget"]["download_failed"].format(url),inline=False)\n', '                    await interaction.response.send_message(embed=embed)\n', '                    return\n', '\n', '                # ファイルを保存\n', "                with open(save_path, 'wb') as file:\n", '                    file.write(await response.read())\n', '        except Exception as e:\n', '            stdin_wget_logger.info("download failed -> " + url + f"({e})")\n', '            embed.add_field(name="",value=f"invalid url -> ({e})",inline=False)\n', '            await interaction.response.send_message(embed=embed)\n', '            return\n', '    stdin_wget_logger.info("download success -> " + url + " to " + save_path)\n', '    embed.add_field(name="",value=RESPONSE_MSG["cmd"]["stdin"]["wget"]["download_success"].format(url,save_path),inline=False)\n', '    await interaction.response.send_message(embed=embed)'], '\n', ['', '', '', '\n', '# コマンドを追加\n', 'tree.add_command(command_group_cmd)']], '', '', '', '\n', ['', '', '', '', '', '', '\n', 'command_group_backup = app_commands.Group(name="backup",description="backup group")\n', '\n', ['', '', '', '', '', '', '', '', '', '\n', 'backup_create_logger = backup_logger.getChild("create")\n', '\n', '#/backup()\n', '@command_group_backup.command(name="create",description=COMMAND_DESCRIPTION[lang]["backup"]["create"])\n', 'async def backup(interaction: discord.Interaction,path:str = "worlds"):\n', '    from_backup = os.path.join(server_path,path)\n', '    world_name = path\n', '    await print_user(backup_logger,interaction.user)\n', '    global exist_files, copyed_files\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/backup create {world_name}")\n', '    #管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["backup create"]:\n', '        await not_enough_permission(interaction,backup_logger) \n', '        return\n', '    #サーバー起動確認\n', '    if is_running_server(backup_logger): \n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # 操作可能パスかを判定\n', '    if not is_path_within_scope(from_backup) or await is_important_bot_file(from_backup):\n', '        backup_logger.error("path not allowed : " + from_backup)\n', '        embed.add_field(name="",value = RESPONSE_MSG["backup"]["create"]["path_not_allowed"] + ":" + from_backup,inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', "    backup_logger.info('backup started')\n", '    #server_path + world_namの存在確認\n', '    if os.path.exists(from_backup):\n', '        await interaction.response.send_message(embed=embed)\n', '        # discordにcopyed_files / exist_filesをプログレスバーで\n', '        await dircp_discord(from_backup,backup_path + "/",interaction,embed)\n', "        backup_logger.info('backup done')\n", '    else:\n', "        backup_logger.error('data not found : ' + from_backup)\n", '        embed.add_field(name="",value=RESPONSE_MSG["backup"]["create"]["data_not_found"] + ":" + from_backup,inline=False)\n', '        await interaction.response.send_message(embed=embed,ephemeral=True)'], ['', '', '', '', '', '', '', '', '\n', '\n', 'backup_apply_logger = backup_logger.getChild("apply")\n', '\n', 'async def server_backup_list(interaction: discord.Interaction, current: str):\n', '    current = current.translate(str.maketrans("/\\\\:","--_"))\n', '    #全てのファイルを取得\n', '    backups = os.listdir(backup_path)\n', '    # current と一致するものを返す & logファイル & 25個制限を実装\n', '    logfiles = [i for i in backups if current in i][-25:]\n', '    # open("./tmp.txt","w").write("\\n".join(logfiles))\n', '    return [\n', '        app_commands.Choice(name = i,value = i) for i in logfiles\n', '    ]\n', '\n', '@command_group_backup.command(name="apply",description="apply backup")\n', '@app_commands.autocomplete(witch=server_backup_list)\n', 'async def backup_apply(interaction:discord.Interaction, witch:str, path:str = ""):\n', '    await print_user(backup_apply_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/backup apply {witch} {path}")\n', '    #管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["backup apply"]: \n', '        await not_enough_permission(interaction,backup_apply_logger)\n', '        return\n', '    #サーバー起動確認\n', '    if is_running_server(backup_apply_logger): \n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # dirの存在確認\n', '    if not os.path.exists(os.path.join(server_path,path)):\n', "        backup_apply_logger.error('data not found : ' + os.path.join(server_path,path))\n", '        embed.add_field(name="",value = RESPONSE_MSG["backup"]["apply"]["path_not_found"] + ":" + os.path.join(server_path,path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    # 操作可能パスかを判定\n', '    if not is_path_within_scope(os.path.join(server_path,path)) or await is_important_bot_file(os.path.join(server_path,path)):\n', '        backup_logger.error("path not allowed : " + os.path.join(server_path,path))\n', '        embed.add_field(name="",value = RESPONSE_MSG["backup"]["apply"]["path_not_allowed"] + ":" + os.path.join(server_path,path),inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    backup_apply_logger.info(\'backup apply started\' + " -> " + witch + " to " + os.path.join(server_path,path,witch))\n', '    await interaction.response.send_message(embed=embed)\n', '    # dircp_discordを用いて進捗を出しつつ、コピーする\n', '    await dircp_discord(os.path.join(backup_path,witch),os.path.join(server_path,path),interaction,embed)\n', "    backup_apply_logger.info('backup apply done')\n", '    '], '\n', 'tree.add_command(command_group_backup)\n'], '', '', '', '\n', ['', '', '', '', '', '', '\n', '#/update\n', '@tree.command(name="update",description=COMMAND_DESCRIPTION[lang]["update"])\n', 'async def update(interaction: discord.Interaction, is_force: bool = False):\n', '    await print_user(update_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/update {is_force}")\n', '    #サーバー起動確認\n', '    if is_running_server(update_logger): \n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    #サーバー管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["update"]: \n', '        await not_enough_permission(interaction,update_logger)\n', '        return\n', '    #py_builder.pyを更新\n', '    await update_self_if_commit_changed(interaction=interaction,embed=embed,text_pack=RESPONSE_MSG["update"],sender=send_discord_message_or_edit,is_force = is_force)'], '', '', '', '\n', ['', '', '', '', '\n', '# グループの設定\n', '# root\n', 'command_group_announce = app_commands.Group(name="announce",description="send messege to discord")\n', '\n', ['', '', '', '', '', '', '', '', '', '\n', '@command_group_announce.command(name="embed",description=COMMAND_DESCRIPTION[lang]["announce"]["embed"])\n', 'async def embed(interaction: discord.Interaction, file: discord.Attachment|None = None, txt: str = ""):\n', '    await print_user(announce_logger,interaction.user)\n', '    return_embed = ModifiedEmbeds.DefaultEmbed(title= f"/embed {file.filename if file is not None else \'\'} {txt}")\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"")\n', '    # 権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["announce embed"]: \n', '        await not_enough_permission(interaction,announce_logger)\n', '        return\n', '    # ファイルとテキストの両方が存在する場合はエラー\n', '    if file is not None and txt != "":\n', '        return_embed.add_field(name="",value=RESPONSE_MSG["cmd"]["announce"]["embed"]["exist_file_and_txt"],inline=False)\n', '        await interaction.response.send_message(embed=return_embed)\n', '        announce_logger.info("file and txt exist")\n', '        return\n', '    # ファイルがある場合はファイルを展開してtxtに代入\n', '    if file is not None:\n', '        try:\n', '            txt = (await file.read()).decode("utf-8")\n', '        except:\n', '            return_embed.add_field(name="",value=RESPONSE_MSG["announce"]["embed"]["decode_error"],inline=False)\n', '            await interaction.response.send_message(embed=return_embed)\n', '            announce_logger.info("file decode error")\n', '            return\n', '    # テキストで送られてるなら\\\\nを改行に変換\n', '    if txt:\n', '        txt = txt.replace("\\\\n","\\n")\n', '        return_embed.add_field(name="",value=RESPONSE_MSG["announce"]["embed"]["replace_slash_n"],inline=False)\n', '    # 内容が空なら\n', '    if txt == "":\n', '        return_embed.add_field(name="",value=RESPONSE_MSG["announce"]["embed"]["empty"],inline=False)\n', '        await interaction.response.send_message(embed=return_embed)\n', '        announce_logger.info("txt is empty")\n', '        return\n', '    send_data, other_dat = await parse_mimd(txt)\n', '    announce_logger.info("parsed txt")\n', '    # embedに追加\n', '    embed.title = other_dat["title"]\n', '    for items in send_data:\n', '        embed.add_field(name=items["name"],value=items["value"],inline=False)\n', '    return_embed.add_field(name="",value=RESPONSE_MSG["announce"]["embed"]["success"],inline=False)\n', '    # embedを送信\n', '    await interaction.response.send_message(embed=return_embed,ephemeral=True)\n', '    # 同じchidにembedを送信\n', '    await interaction.channel.send(embed=embed)\n', "    announce_logger.info('embed sent')\n", '\n', '\n'], '', '', '', '\n', 'tree.add_command(command_group_announce)'], '', '', '', '\n', '#/replace <py file>\n', '# @tree.command(name="replace",description=COMMAND_DESCRIPTION[lang]["replace"])\n', '# async def replace(interaction: discord.Interaction,py_file:discord.Attachment):\n', '#     await print_user(replace_logger,interaction.user)\n', '#     embed = ModifiedEmbeds.DefaultEmbed(title= f"/replace {py_file.filename}")\n', '#     #デフォルトでコマンドを無効に\n', '#     if not allow["replace"]:\n', '#         embed.add_field(name=RESPONSE_MSG["replace"]["not_allow"]["name"],value=RESPONSE_MSG["replace"]["not_allow"]["value"],inline=False)\n', '#         await interaction.response.send_message(embed=embed)\n', '#         return\n', '#     #管理者権限を要求\n', '#     if await user_permission(interaction.user) < COMMAND_PERMISSION["replace"]:\n', '#         await not_enough_permission(interaction,replace_logger)\n', '#         return\n', '#     #サーバー起動確認\n', '#     if is_running_server(replace_logger): \n', '#         embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '#         await interaction.response.send_message(embed=embed)\n', '#         return\n', "#     replace_logger.info('replace started')\n", '#     # ファイルをすべて読み込む\n', '#     with open(temp_path + "/new_source.py","w",encoding="utf-8") as f:\n', '#         f.write((await py_file.read()).decode("utf-8").replace("\\r\\n","\\n"))\n', '#     # discordにコードを置き換える\n', "#     replace_logger.info('replace done')\n", '#     embed.add_field(name="",value=RESPONSE_MSG["replace"]["progress"],inline=False)\n', '#     await interaction.response.send_message(embed=embed)\n', '#     response = await interaction.original_response()\n', '#     #interaction id を保存\n', '#     msg_id = str(response.id)\n', '#     channel_id = str(interaction.channel_id)\n', '#     replace_logger.info("call update.py")\n', '#     replace_logger.info(\'replace args : \' + msg_id + " " + channel_id)\n', '#     os.execv(sys.executable,["python3",now_path + "/mikanassets/" + "update.py",temp_path + "/new_source.py",msg_id,channel_id,now_file])\n', '\n', '#/ip\n', '@tree.command(name="ip",description=COMMAND_DESCRIPTION[lang]["ip"])\n', 'async def ip(interaction: discord.Interaction):\n', '    await print_user(ip_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/ip")\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["ip"]:\n', '        await not_enough_permission(interaction,ip_logger)\n', '        return\n', '    if not allow["ip"]:\n', '        embed.add_field(name="",value=RESPONSE_MSG["ip"]["not_allow"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', "        ip_logger.error('ip is not allowed')\n", '        return\n', '    # ipをget\n', '    try:\n', '        addr = requests.get("https://api.ipify.org")\n', '    except:\n', "        ip_logger.error('get ip failed')\n", '        embed.add_field(name="",value=RESPONSE_MSG["ip"]["get_ip_failed"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    if config["mc"]:\n', '        ip_logger.info(\'get ip : \' + addr.text + ":" + properties["server-port"])\n', '        embed.add_field(name=RESPONSE_MSG["ip"]["msg_startwith"] + addr.text + ":" + properties["server-port"],value=f"(ip:{addr.text} port(ポート):{properties[\'server-port\']})",inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '    else:\n', "        ip_logger.info('get ip : ' + addr.text)\n", '        embed.add_field(name="",value=RESPONSE_MSG["ip"]["msg_startwith"] + addr.text,inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '\n', '\n', 'async def get_log_files_choice_format(interaction: discord.Interaction, current: str):\n', '    current = current.translate(str.maketrans("/\\\\:","--_"))\n', '    #全てのファイルを取得\n', '    s_logfiles = os.listdir(server_path + "logs/")\n', '    a_logfiles = os.listdir(now_path + "/logs/")\n', '    logfiles = (s_logfiles + a_logfiles)\n', '    # current と一致するものを返す & logファイル & 25個制限を実装\n', '    logfiles = [i for i in logfiles if current in i and i.endswith(".log")][-25:]\n', '    # open("./tmp.txt","w").write("\\n".join(logfiles))\n', '    return [\n', '        app_commands.Choice(name = i,value = i) for i in logfiles\n', '    ]\n', '\n', '\n', '#/log <filename>\n', '# filename : ログファイル名\n', '# filename == None -> 最新のログ10件\n', '# filename != None -> server_path + "logs/" または now_path + "logs/"の中を候補表示する\n', '@tree.command(name="logs",description=COMMAND_DESCRIPTION[lang]["logs"])\n', '@app_commands.autocomplete(filename = get_log_files_choice_format)\n', 'async def logs(interaction: discord.Interaction,filename:str = None):\n', '    await print_user(log_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/logs {filename}")\n', '    #管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["logs"]: \n', '        await not_enough_permission(interaction,log_logger)\n', '        return\n', '    # discordにログを送信\n', '    if filename is None:\n', '        # 2000文字こ超えない最長のログを取得\n', '        send_msg = []\n', '        send_length = 0\n', '        for i in log_msg:\n', '            send_length += len(i)\n', '            send_msg.append(i)\n', '            while True:\n', '                if send_length > 1900:\n', '                    delete = send_msg.pop(0)\n', '                    send_length -= len(delete)\n', '                else:\n', '                    break\n', '        # embed.add_field(name="",value="```ansi\\n" + "\\n".join(send_msg) + "\\n```",inline=False)\n', '        await interaction.response.send_message("```ansi\\n" + "\\n".join(send_msg) + "\\n```")\n', '    else:\n', '        if "/" in filename or "\\\\" in filename or "%" in filename:\n', '            log_logger.error(\'invalid filename : \' + filename + "\\n" + f"interaction user / id：{interaction.user} {interaction.user.id}")\n', '            embed.add_field(name="",value=RESPONSE_MSG["logs"]["cant_access_other_dir"],inline=False)\n', '            await interaction.response.send_message(embed=embed)\n', '            return\n', '        elif not filename.endswith(".log"):\n', '            log_logger.error(\'invalid filename : \' + filename + "\\n" + f"interaction user / id：{interaction.user} {interaction.user.id}")\n', '            embed.add_field(name="",value=RESPONSE_MSG["logs"]["not_found"],inline=False)\n', '            await interaction.response.send_message(embed=embed)\n', '            return\n', '        elif filename.startswith("server"):\n', '            filename = server_path + "logs/" + filename\n', '        elif filename.startswith("all"):\n', '            filename = now_path + "/logs/" + filename\n', '        else:\n', '            filename = server_path + "logs/" + filename\n', '            if not os.path.exists(filename):\n', '                if os.path.exists(now_path + "/logs/" + filename):\n', '                    filename = now_path + "/logs/" + filename\n', '                else:\n', '                    log_logger.error(\'invalid filename : \' + filename + "\\n" + f"interaction user / id：{interaction.user} {interaction.user.id}")\n', '                    embed.add_field(name="",value=RESPONSE_MSG["logs"]["not_found"],inline=False)\n', '                    await interaction.response.send_message(embed=embed)\n', '                    return\n', '        #ファイルを返却\n', '        await interaction.response.send_message(file=discord.File(filename))\n', '    log_ = "Server logs" if filename is None else filename\n', '    log_logger.info(f"sended logs -> {log_}")\n', '\n', '\n', 'def gen_web_token():\n', '    from random import choices\n', '    from string import ascii_letters, digits\n', "    return ''.join(choices(ascii_letters + digits, k=12))\n", '\n', '#/tokengen トークンを生成する\n', '@tree.command(name="tokengen",description=COMMAND_DESCRIPTION[lang]["tokengen"])\n', 'async def tokengen(interaction: discord.Interaction):\n', '    await print_user(token_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/tokengen")\n', '    #権限レベルを確認\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["tokengen"]:\n', '        await not_enough_permission(interaction,token_logger)\n', '        return\n', '    new_token = gen_web_token()\n', '    embed.add_field(name=RESPONSE_MSG["tokengen"]["success"].format(""),value=new_token,inline=False)\n', '    await interaction.response.send_message(embed=embed,ephemeral=True)\n', "    token_logger.info('token sent')\n", '    #トークンをファイルに書き込む\n', '    dat_token = {"token":new_token, "deadline":(datetime.now() + timedelta(days=30)).strftime("%Y-%m-%d %H:%M:%S")}\n', '    web_tokens.append(dat_token)\n', '    with open(now_path + "/mikanassets/web/usr/tokens.json","r",encoding="utf-8") as f:\n', '        item = json.load(f)\n', '        item["tokens"].append(dat_token)\n', '    with open(now_path + "/mikanassets/web/usr/tokens.json","w",encoding="utf-8") as f:\n', '        json.dump(item,f,indent=4,ensure_ascii=False)\n', "    token_logger.info('token added : ' + str(dat_token))\n", '\n', ['', '', '', '', '', '', '', '', '\n', 'command_group_terminal = app_commands.Group(name="terminal",description="terminal group")\n', '\n', 'async def change_terminal_ch(channel: int | bool, logger: logging.Logger):    \n', '    global where_terminal\n', '    #terminalを無効化\n', '    where_terminal = channel\n', '    config["discord_commands"]["terminal"]["discord"] = where_terminal\n', '    logger.info(f"terminal setting -> {where_terminal}")\n', '    await rewrite_config(config=config)\n', '\n', ['', '', '', '', '', '', '', '', '', '\n', 'terminal_set_logger = terminal_logger.getChild("set")\n', '\n', '#/terminal\n', '@command_group_terminal.command(name="set",description=COMMAND_DESCRIPTION[lang]["terminal"]["set"])\n', 'async def terminal_set(interaction: discord.Interaction, channel:discord.TextChannel = None):\n', '    global where_terminal\n', '    await print_user(terminal_set_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/terminal set {channel}")\n', '    # 権限レベルが足りていないなら\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["terminal set"]:\n', '        await not_enough_permission(interaction,terminal_set_logger)\n', '        return\n', '    #発言したチャンネルをwhere_terminalに登録\n', '    await change_terminal_ch(channel.id if channel else interaction.channel.id, terminal_set_logger)\n', '    embed.add_field(name="",value=RESPONSE_MSG["terminal"]["success"].format(where_terminal),inline=False)\n', '    await interaction.response.send_message(embed=embed)'], '', '', '', ['', '', '', '', '', '', '', '', '', '\n', 'terminal_delete_logger = terminal_logger.getChild("delete")\n', '\n', '#/terminal\n', '@command_group_terminal.command(name="del",description=COMMAND_DESCRIPTION[lang]["terminal"]["del"])\n', 'async def terminal_set(interaction: discord.Interaction):\n', '    global where_terminal\n', '    await print_user(terminal_delete_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/terminal del")\n', '    # 権限レベルが足りていないなら\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["terminal del"]:\n', '        await not_enough_permission(interaction,terminal_delete_logger)\n', '        return\n', '    #発言したチャンネルをwhere_terminalに登録\n', '    await change_terminal_ch(False, terminal_delete_logger)\n', '    embed.add_field(name="",value=RESPONSE_MSG["terminal"]["success"].format(where_terminal),inline=False)\n', '    await interaction.response.send_message(embed=embed)\n'], '', '', '', '\n', 'tree.add_command(command_group_terminal)\n'], '', '', '', '\n', ['', '', '', '', '', '', '', '', '', '\n', 'async def get_process_memory(process: subprocess.Popen | None) -> dict:\n', '    MB = 1024**2\n', '    # このプログラムの利用メモリを取得する\n', '    origin_process = psutil.Process(os.getpid())\n', '    origin_mem = origin_process.memory_info().rss / MB\n', '    # サーバープロセスの利用メモリを取得する\n', '    if process is not None:\n', '        childs = psutil.Process(process.pid).children(recursive=True)\n', '        server_mem = sum([psutil.Process(child.pid).memory_info().wset for child in childs]) / MB\n', '        server_mem += (psutil.Process(process.pid)).memory_info().wset / MB\n', '    else:\n', '        server_mem = 0\n', '    return {\n', '        "origin_mem": origin_mem,\n', '        "server_mem": server_mem\n', '    }\n', '\n', 'async def get_process_cpu(process: subprocess.Popen) -> float:\n', '    return psutil.cpu_percent(interval=1.0)\n', '\n', 'async def get_thread_cpu_usage(pid : int, interval=1.0, is_self = False):\n', '    # 全てのスレッドを取得\n', '    process = psutil.Process(pid)\n', '    # 初回のCPU時間を取得\n', '    thread_cpu_times = {t.id: t.user_time + t.system_time for t in process.threads()}\n', '    # 1秒間のCPU使用率を取得\n', '    await asyncio.sleep(interval)\n', '    # CPU時間の差分を取得\n', '    tmp_cpu_times = {t.id: t.user_time + t.system_time for t in process.threads()}\n', '    for tid in thread_cpu_times:\n', '        try:\n', '            thread_cpu_times[tid] = tmp_cpu_times[tid] - thread_cpu_times[tid]\n', '        except KeyError:\n', '            thread_cpu_times[tid] = 0\n', '    # 全体のCPU時間を取得\n', '    sum_cpu_times = sum(thread_cpu_times.values())\n', '    # is_selfがtrueであれば、自身の名前に置き換える\n', '    if is_self:\n', '    # スレッド名の辞書を作成\n', '        items = {thread.ident: thread.name for thread in threading.enumerate()}\n', '        # 一時辞書を用意（ループ中の辞書変更を防ぐ）\n', '        updated_thread_cpu_times = {}\n', '        # IDをスレッド名に変換\n', '        for thread_id, cpu_time in thread_cpu_times.items():\n', '            if thread_id in items:\n', '                updated_thread_cpu_times[items[thread_id]] = cpu_time\n', '            else:\n', '                updated_thread_cpu_times[thread_id] = cpu_time\n', '        # 名前のないスレッドを "NoName Thread x" にする\n', '        no_name_thread_count = 1\n', '        final_thread_cpu_times = {}\n', '        for key, cpu_time in updated_thread_cpu_times.items():\n', '            if isinstance(key, int):  # スレッドIDが残っている場合\n', '                final_thread_cpu_times[f"NoName {no_name_thread_count}"] = cpu_time\n', '                no_name_thread_count += 1\n', '            else:\n', '                final_thread_cpu_times[key] = cpu_time\n', '        # 更新後の辞書を適用\n', '        thread_cpu_times = final_thread_cpu_times\n', '    # 全体のCPU時間を取得\n', '    sum_cpu_times = sum(thread_cpu_times.values())\n', '\n', '    status_logger.debug(f"thread_cpu_times: {thread_cpu_times}")\n', '    status_logger.debug(f"sum_cpu_times: {sum_cpu_times}")\n', '\n', '    # threadごとのパーセントを計算\n', '    cpu_usage = {\n', '        tid: (thread_cpu_times[tid] / sum_cpu_times) * 100 if sum_cpu_times != 0 else 0\n', '        for tid in thread_cpu_times\n', '    }\n', '\n', '    status_logger.debug(f"cpu_usage: {cpu_usage}")\n', '    \n', '    process_cpu = await get_process_cpu(process)\n', '\n', '    status_logger.debug(f"process_cpu: {process_cpu}")\n', '\n', '    # CPU使用率を計算\n', '    cpu_usage = {\n', '        tid : cpu_usage[tid] / 100 * process_cpu\n', '        for tid in cpu_usage\n', '    }\n', '\n', '    status_logger.debug(f"cpu_usage: {cpu_usage}")\n', '\n', '    return cpu_usage\n', '\n', 'async def check_response(url:str = "http://127.0.0.1"):\n', '    try:\n', '        async with aiohttp.ClientSession() as session:\n', '            async with session.get(url, timeout=5) as response:\n', '                if response.status == 200:\n', '                    sys_logger.info("Waitress server is running.")\n', '                    return True\n', '                else:\n', '                    sys_logger.info(f"Server returned status code: {response.status}")\n', '                    return False\n', '    except aiohttp.ClientError as e:\n', '        sys_logger.info(f"Server is not running: {e}")\n', '        return False\n', '\n', '#/status\n', '@tree.command(name="status",description=COMMAND_DESCRIPTION[lang]["status"])\n', 'async def status(interaction: discord.Interaction):\n', '    await print_user(status_logger,interaction.user)\n', '    await interaction.response.defer()\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/status")\n', '    # 権限の確認\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["status"]:\n', '        await not_enough_permission(interaction,status_logger)\n', '        return\n', '    \n', '    # プログラムの利用メモリを取得する\n', '    memorys = await get_process_memory(process)\n', '    embed.add_field(name=RESPONSE_MSG["status"]["mem_title"],value=RESPONSE_MSG["status"]["mem_value"].format(round(memorys["origin_mem"],2)) + "\\n" + RESPONSE_MSG["status"]["mem_server_value"].format(round(memorys["server_mem"],2)))\n', '\n', '    status_logger.info(f"get memory -> process {memorys[\'origin_mem\']}, server {memorys[\'server_mem\']}")\n', '\n', '    # online状態を取得する\n', '    is_server_online = "🟢" if process is not None and process.poll() is None else "🔴"\n', '    is_waitress_online = "🟢" if await check_response(f"http://127.0.0.1:{web_port}") else "🔴"\n', '    is_bot_online = "🟢"\n', '    embed.add_field(name=RESPONSE_MSG["status"]["online_title"],value=RESPONSE_MSG["status"]["online_value"].format(is_server_online, is_waitress_online, is_bot_online))\n', '\n', '    # SERVER PROCESS CPUの利用率を取得する\n', '    if process is not None:\n', '        cpu_usage = {server_name :(await get_process_cpu(process.pid))}\n', '    else:\n', '        cpu_usage = {"NULL": "NULL"}\n', '    send_str = ["Server"]\n', '    send_str += [RESPONSE_MSG["status"]["cpu_value_proc"].format(cpu_usage[key], key) for key in cpu_usage]\n', '    # BOT PROCESS CPUの利用率を取得する\n', '    cpu_usage = await get_thread_cpu_usage(os.getpid(), is_self=True)\n', '    send_str += ["Self"]\n', '    send_str += [RESPONSE_MSG["status"]["cpu_value_thread"].format(cpu_usage[key], key) for key in cpu_usage]\n', '    embed.add_field(name=RESPONSE_MSG["status"]["cpu_title"],value="\\n".join(send_str), inline=False)\n', '\n', '    status_logger.info(f"get cpu usage -> {\' \'.join(send_str)}")\n', '\n', '    # 基本情報を記載\n', '    embed.add_field(name=RESPONSE_MSG["status"]["base_title"],value=RESPONSE_MSG["status"]["base_value"].format(platform.system() + " " + platform.release(), sys.version, get_version()), inline=True)\n', '\n', '    await interaction.edit_original_response(embed=embed)\n', "    status_logger.info('status command end')"], '', '', '', '\n', '#/help\n', '@tree.command(name="help",description=COMMAND_DESCRIPTION[lang]["help"])\n', 'async def help(interaction: discord.Interaction):\n', '    await print_user(help_logger,interaction.user)\n', '    await interaction.response.send_message(embed=send_help)\n', "    help_logger.info('help sent')\n", '\n', '#/exit\n', '@tree.command(name="exit",description=COMMAND_DESCRIPTION[lang]["exit"])\n', 'async def exit(interaction: discord.Interaction):\n', '    await print_user(exit_logger,interaction.user)\n', '    embed = ModifiedEmbeds.DefaultEmbed(title= f"/exit")\n', '    #管理者権限を要求\n', '    if await user_permission(interaction.user) < COMMAND_PERMISSION["exit"]: \n', '        await not_enough_permission(interaction,exit_logger)\n', '        return\n', '    #サーバが動いているなら終了\n', '    if is_running_server(exit_logger): \n', '        embed.add_field(name="",value=RESPONSE_MSG["other"]["is_running"],inline=False)\n', '        await interaction.response.send_message(embed=embed)\n', '        return\n', '    embed.add_field(name="",value=RESPONSE_MSG["exit"]["success"],inline=False)\n', '    await interaction.response.send_message(embed=embed)\n', "    exit_logger.info('exit')\n", '    await client.close()\n', '    #waitressサーバーを終了\n', '\n', '    sys.exit()\n', '\n', '# 拡張コマンドを読み込む\n', ['', '', '', '', '', '', '', '', '\n', '\n', 'def get_process():\n', '    return process\n', '\n', 'def append_tasks_func(func):\n', '    extension_tasks_func.append(func)\n', '    return\n', '\n', 'is_write_server_block = False\n', 'def write_server_in(command: str):\n', '    global is_write_server_block\n', '    if is_write_server_block:\n', '        return False, "write_server_block"\n', '    is_write_server_block = True\n', '    # サーバーが動いていれば、コマンドを送る\n', '    if is_stopped_server(sys_logger):\n', '        is_write_server_block = False\n', '        return False, "server_is_not_running"\n', '    process.stdin.write(command + "\\n")\n', '    process.stdin.flush()\n', '    is_write_server_block = False\n', '    return True, "success"'], ['', '', '', '', '', '', '', '', 'base_extension_logger.info("search extension commands")\n', 'extension_commands_group = None\n', 'extension_logger = None\n', 'def read_extension_commands():\n', '    global extension_commands_group,extension_logger\n', '    extension_commands_groups = deque()\n', '    sys_logger.info("read extension commands ->" + now_path + "/mikanassets/extension")\n', '    # 拡張moduleに追加コマンドが存在すればするだけ読み込む(mikanassets/extension/<拡張名>/commands.py)\n', '    for file in os.listdir(now_path + "/mikanassets/extension"):\n', '        if os.path.isdir(now_path + "/mikanassets/extension/" + file):\n', '            sys_logger.info("read extension commands ->" + now_path + "/mikanassets/extension/" + file)\n', '            if os.path.exists(now_path + "/mikanassets/extension/" + file + "/commands.py"):\n', '                # <拡張名>コマンドグループを作成\n', '                extension_commands_group = app_commands.Group(name="extension-" + file,description="This commands group is extention.\\nUse this code at your own risk." + file)\n', '                extension_commands_groups.append(extension_commands_group)\n', '                # 拡張moduleが/mikanassets/extension/<拡張名>/commans.pyにある場合は読み込む\n', '                try:\n', '                    extension_logger = base_extension_logger.getChild(file)\n', '                    importlib.import_module("mikanassets.extension." + file + ".commands")\n', '                    # コマンドを追加\n', '                    tree.add_command(extension_commands_group)\n', '                    sys_logger.info("read extension commands success -> " + now_path + "/mikanassets/extension/" + file + "/commands.py")\n', '                except Exception as e:\n', '                    sys_logger.info("cannot read extension commands " + now_path + "/mikanassets/extension/" + file + "/commands.py" + f"({e})")\n', '            else:\n', '                sys_logger.info("not exist extension commands file in " + now_path + "/mikanassets/extension/" + file + "/commands.py")\n', '        else:\n', '            sys_logger.info("not directory -> " + now_path + "/mikanassets/extension/" + file)\n', '\n', '    unti_GC_obj.append(extension_commands_groups)\n', '\n', '# mikanassets/extension/<extension_dir>にディレクトリが存在すれば\n', 'if os.path.exists(now_path + "/mikanassets/extension"):\n', '    if len(os.listdir(now_path + "/mikanassets/extension")) > 0:\n', '        # 拡張コマンドを読み込む\n', '        read_extension_commands()\n', '    else:\n', '        sys_logger.info("no extension commands in " + now_path + "/mikanassets/extension")\n', 'del extension_commands_group\n', '\n'], '\n', 'import traceback\n', '\n', '#コマンドがエラーの場合\n', '@tree.error\n', 'async def on_error(interaction: discord.Interaction, error: Exception):\n', '    try:\n', '        sys_logger.error(error)\n', '        sys_logger.error(traceback.format_exc())\n', '        await interaction.response.send_message(RESPONSE_MSG["error"]["error_base"] + str(error))\n', '    except Exception as e:\n', '        sys_logger.error(e)\n', '        sys_logger.error(traceback.format_exc())\n', '        '], '\n', '# flask関連コードの読み込み\n', ['', '', '', '', '', '', '', '', '', '', '', '', '\n', '\n', 'app = Flask(__name__,template_folder="mikanassets/web",static_folder="mikanassets/web")\n', 'app.secret_key = flask_secret_key\n', 'flask_logger = create_logger("werkzeug",Formatter.WebFormatter("FLASK",f\'{Color.BOLD + Color.BG_BLACK}%(asctime)s %(levelname)s %(name)s: %(message)s\', dt_fmt),Formatter.WebConsoleFormatter("FLASK",\'%(asctime)s %(levelname)s %(name)s: %(message)s\', datefmt=dt_fmt))\n', 'uvicorn_logger_err = create_logger("uvicorn.error",Formatter.WebFormatter("UVICORN",f\'{Color.BOLD + Color.BG_BLACK}%(asctime)s %(levelname)s %(name)s: %(message)s\', dt_fmt),Formatter.WebConsoleFormatter("UVICORN",\'%(asctime)s %(levelname)s %(name)s: %(message)s\', datefmt=dt_fmt))\n', 'uvicorn_logger = create_logger("uvicorn.access",Formatter.WebFormatter("UVICORN",f\'{Color.BOLD + Color.BG_BLACK}%(asctime)s %(levelname)s %(name)s: %(message)s\', dt_fmt),Formatter.WebConsoleFormatter("UVICORN",\'%(asctime)s %(levelname)s %(name)s: %(message)s\', datefmt=dt_fmt))\n', '\n', 'class ExcludeGetConsoleDataFilter(logging.Filter):\n', '    def filter(self, record):\n', '        # record.args はログ出力の引数、record.msg が生ログ文字列\n', '        # "GET /get_console_data" を含むかどうかを確認\n', '        return "/get_console_data" not in str(record.getMessage())\n', 'for logger in [flask_logger,uvicorn_logger_err,uvicorn_logger]:\n', '    logger.addFilter(ExcludeGetConsoleDataFilter())\n', '# def get_uvicorn_custom_log_config():\n', '#     from uvicorn.config import LOGGING_CONFIG\n', '#     uvicorn_custom_log_config = LOGGING_CONFIG.copy()\n', '#     uvicorn_custom_log_config["formatters"]["default"]["fmt"] = f\'{Color.BOLD + Color.BLACK}%(asctime)s {Color.BOLD + Color.CYAN}UVICORN  {Color.RESET.value}%(name)s: %(message)s\'\n', '#     uvicorn_custom_log_config["formatters"]["default"]["datefmt"] = "%Y-%m-%d %H:%M:%S"\n', '#     uvicorn_custom_log_config["formatters"]["access"]["fmt"] = f\'{Color.BOLD + Color.BLACK}%(asctime)s {Color.BOLD + Color.CYAN}UVICORN  {Color.RESET.value}%(name)s: %(message)s\'\n', '#     uvicorn_custom_log_config["formatters"]["access"]["datefmt"] = "%Y-%m-%d %H:%M:%S"\n', '\n', '#     class ExcludeGetConsoleDataFilter(logging.Filter):\n', '#         def filter(self, record):\n', '#             # record.args はログ出力の引数、record.msg が生ログ文字列\n', '#             # "GET /get_console_data" を含むかどうかを確認\n', '#             return "/get_console_data" not in str(record.getMessage())\n', '\n', '#     uvicorn_custom_log_config["filters"] = {\n', '#         "exclude_get_console_data": {\n', '#             "()": ExcludeGetConsoleDataFilter,\n', '#         }\n', '#     }\n', '#     uvicorn_custom_log_config["handlers"]["access"]["filters"] = ["exclude_get_console_data"]\n', '#     return uvicorn_custom_log_config\n', '\n', '# fastapi_logger = [\n', '#     create_logger("uvicorn.access", Formatter.WebFormatter("UVICORN",f\'{Color.BOLD + Color.BG_BLACK}%(asctime)s %(levelname)s %(name)s: %(message)s\', dt_fmt), Formatter.WebConsoleFormatter("UVICORN",\'%(asctime)s %(levelname)s %(name)s: %(message)s\', datefmt=dt_fmt)),\n', '#     create_logger("uvicorn", Formatter.WebFormatter("UVICORN",f\'{Color.BOLD + Color.BG_BLACK}%(asctime)s %(levelname)s %(name)s: %(message)s\', dt_fmt), Formatter.WebConsoleFormatter("UVICORN",\'%(asctime)s %(levelname)s %(name)s: %(message)s\', datefmt=dt_fmt)),\n', '#     create_logger("uvicorn.error", Formatter.WebFormatter("UVICORN",f\'{Color.BOLD + Color.BG_BLACK}%(asctime)s %(levelname)s %(name)s: %(message)s\', dt_fmt), Formatter.WebConsoleFormatter("UVICORN",\'%(asctime)s %(levelname)s %(name)s: %(message)s\', datefmt=dt_fmt)),\n', '\n', '#     ]\n', '\n', 'class LogIPMiddleware:\n', '    def __init__(self, app):\n', '        self.app = app\n', '        # self.before_log = {"Client IP": "", "Method": "", "URL": "", "Query": ""}\n', '\n', '    def __call__(self, environ, start_response):\n', '        # クライアントのIPアドレスを取得\n', "        client_ip = environ.get('REMOTE_ADDR', '')\n", '        # リクエストされたURLを取得\n', "        request_method = environ.get('REQUEST_METHOD', '')\n", "        request_uri = environ.get('PATH_INFO', '')\n", "        query_string = environ.get('QUERY_STRING', '')\n", '\n', '        # ログに記録\n', '        if request_uri != "/get_console_data":\n', '            flask_logger.info(f"Client IP: {client_ip}, Method: {request_method}, URL: {request_uri}, Query: {query_string}")\n', '\n', '        return self.app(environ, start_response)\n', '    \n', '# class LogIPMiddlewareASGI:\n', '#     def __init__(self, app):\n', '#         self.app = app\n', '\n', '#     async def __call__(self, scope, receive, send):\n', '#         if scope["type"] == "http":\n', '#             client = scope.get("client")\n', '#             method = scope.get("method")\n', '#             path = scope.get("path")\n', '#             query_string = scope.get("query_string", b"").decode("utf-8")\n', '\n', '#             if path != "/get_console_data":\n', '#                 client_ip = client[0] if client else "unknown"\n', '#                 flask_logger.info(\n', '#                     f"Client IP: {client_ip}, Method: {method}, URL: {path}, Query: {query_string}"\n', '#                 )\n', '\n', '#         await self.app(scope, receive, send)\n', '\n', '# ミドルウェアをアプリに適用\n', 'app.wsgi_app = LogIPMiddleware(app.wsgi_app)\n', '\n', '\n', '# トークンをロードする\n', 'def load_tokens():\n', '    tokens = set()\n', '    try:\n', '        items = web_tokens\n', '        now = datetime.now()\n', '        for token in items:\n', '            if datetime.strptime(token["deadline"], "%Y-%m-%d %H:%M:%S") > now:\n', '                tokens.add(token["token"])\n', '        return tokens\n', '    except FileNotFoundError:\n', '        flask_logger.info(f"Token file not found: {WEB_TOKEN_FILE}")\n', '        return {}\n', '\n', '# トークンを検証する\n', 'def is_valid_token(token):\n', '    tokens = load_tokens()\n', '    return token in tokens\n', '\n', 'def is_valid_session(token):\n', "    if 'token' not in session:\n", '        # ログアウトにリダイレクトするためのフラグを返す\n', '        return False\n', "    if not is_valid_token(session['token']):\n", '        #ログアウト\n', '        # ログアウトにリダイレクトするためのフラグを返す\n', '        return False\n', '    return True\n', '\n', '\n', '# クッキーからトークンを取得し、セッションにセット\n', '@app.before_request\n', 'def load_token_from_cookie():\n', "    token = request.cookies.get('token')\n", '    if token and is_valid_token(token):\n', "        session['token'] = token\n", '\n', "@app.route('/', methods=['GET', 'POST'])\n", 'def index():\n', '    # セッションにトークンがある場合、ログイン済み\n', "    if 'token' in session:\n", "        if is_valid_token(session['token']):\n", "            return render_template('index.html', logs = log_msg)\n", '\n', '    # ログアウトさせられた場合理由を表示\n', "    if 'logout_reason' in session:\n", "        flash(session['logout_reason'])\n", "        session.pop('logout_reason') \n", '\n', "    if request.method == 'POST':\n", "        token = request.form['token']\n", '        if is_valid_token(token):\n', '            # トークンをセッションとクッキーに保存\n', "            session['token'] = token\n", "            resp = make_response(redirect(url_for('index')))\n", '            \n', '            # クッキーにトークンを保存、有効期限を30日間に設定\n', '            expires = datetime.now() + timedelta(days=30)\n', "            resp.set_cookie('token', token, expires=expires)\n", '\n', '            return resp\n', '        else:\n', "            flash('Invalid token, please try again.')\n", '\n', "    return render_template('login.html')\n", '\n', "@app.route('/logout')\n", 'def logout():\n', '    # セッションとクッキーからトークンを削除してログアウト\n', "    session.pop('token', None)\n", "    resp = make_response(redirect(url_for('index')))\n", "    resp.set_cookie('token', '', expires=0)  # クッキーを無効化\n", '    return resp\n', '\n', "# @app.route('/')\n", '# def index():\n', "#     return render_template('index.html', logs = log_msg)\n", '\n', "@app.route('/get_console_data')\n", 'def get_console_data():\n', "    if not is_valid_session(session['token']):\n", '        # ログアウト\n', '        session["logout_reason"] = "This token has expired. create new token."\n', '        return jsonify({"redirect": url_for(\'logout\')})\n', '    \n', '    converter = Ansi2HTMLConverter()\n', '    html_string = converter.convert("\\n".join(log_msg))\n', '\n', '    try:\n', '        server_online = process.poll() is None#サーバーが起動している = True\n', '    except:\n', '        if process is not None:\n', '            process.kill()\n', '        server_online = False\n', '\n', '    bot_online = True\n', '\n', '    return jsonify({"html_string": html_string, "online_status": {"server": server_online, "bot": bot_online}})\n', '\n', '\n', "@app.route('/flask_start_server', methods=['POST'])\n", 'def flask_start_server():\n', "    if not is_valid_session(session['token']):\n", '        # ログアウト\n', '        session["logout_reason"] = "This token has expired. create new token."\n', '        return jsonify({"redirect": url_for(\'logout\')})\n', '    result = core_start()\n', '    if result == RESPONSE_MSG["other"]["is_running"]:\n', '        return jsonify(RESPONSE_MSG["other"]["is_running"])\n', '    return jsonify(result)\n', '\n', "@app.route('/flask_backup_server', methods=['POST'])\n", 'def flask_backup_server():\n', "    if not is_valid_session(session['token']):\n", '        # ログアウト\n', '        session["logout_reason"] = "This token has expired. create new token."\n', '        return jsonify({"redirect": url_for(\'logout\')})\n', "    world_name = request.form['fileName']\n", '    if "\\\\" in world_name or "/" in world_name:\n', '        return jsonify(RESPONSE_MSG["backup"]["not_allowed_path"] + ":" + server_path + world_name)\n', '    if process is None:\n', '        if os.path.exists(server_path + world_name):\n', '            backup_logger.info("backup server")\n', '            to = backup_path + "/" + datetime.now().strftime(\'%Y-%m-%d_%H_%M_%S\')\n', '            copytree(server_path + world_name,to)\n', '            backup_logger.info("backuped server to " + to)\n', '            return jsonify("backuped server!! " + to)\n', '        else:\n', "            backup_logger.info('data not found : ' + server_path + world_name)\n", '            return jsonify(RESPONSE_MSG["backup"]["data_not_found"] + ":" + server_path + world_name)\n', '    else:\n', '        return jsonify(RESPONSE_MSG["other"]["is_running"])\n', '\n', "@app.route('/submit_data', methods=['POST'])\n", 'def submit_data():\n', '    global use_stop\n', "    if not is_valid_session(session['token']):\n", '        # ログアウト\n', '        session["logout_reason"] = "This token has expired. create new token."\n', '        return jsonify({"redirect": url_for(\'logout\')})\n', "    user_input = request.form['userInput']\n", '    #サーバーが起きてるかを確認\n', '    if process is None:\n', '        return jsonify("server is not running")\n', '    #ifに引っかからない = サーバーが起動している\n', '\n', '    #もし入力されたコマンドがstopだったら\n', '    if user_input == STOP:\n', '        use_stop = True\n', '\n', '    #サーバーの標準入力に入力\n', '    process.stdin.write(user_input + "\\n")\n', '    process.stdin.flush()\n', '\n', '    # データを処理し、結果を返す（例: メッセージを返す）\n', '    return jsonify(f"result: {user_input}")\n', '\n', 'def run_webservice_server():\n', '    fastapi_app = SendDiscordSelfServer.create_app()\n', '    if use_flask_server:\n', '        fastapi_app.mount("/", WSGIMiddleware(app))\n', '    # fastapi_app = LogIPMiddlewareASGI(fastapi_app)\n', '    uvicorn.run(fastapi_app, host="0.0.0.0", port=web_port, log_config=None)\n', '\n', '    \n', 'web_thread = threading.Thread(target=run_webservice_server, daemon=True)\n', 'web_thread.start()\n', '\n'], '\n', '# discordロガーの設定\n', ['', '', '', '', '', '\n', '# discord.py用のロガーを取得して設定\n', "discord_logger = logging.getLogger('discord')\n", 'if log["all"]:\n', '    file_handler = logging.FileHandler(now_path + "/logs/all " + start_time + ".log")\n', '    file_handler.setFormatter(file_formatter)\n', '    discord_logger.addHandler(file_handler)'], '\n', '\n', '# 事実上のエントリポイント(client.runを実行)\n', '', '', '', '', 'client.run(token, log_formatter=console_formatter)\n']